[{"title":"CocoaPods 升级报错","date":"2019-01-07T13:14:29.000Z","path":"2019/01/07/CocoaPods-升级报错/","text":"CocoaPods 升级报错 内容123456Traceback (most recent call last): 4: from /Users/iosdev/.rvm/gems/ruby-2.5.3/bin/ruby_executable_hooks:24:in `&lt;main&gt;' 3: from /Users/iosdev/.rvm/gems/ruby-2.5.3/bin/ruby_executable_hooks:24:in `eval' 2: from /usr/local/bin/pod:23:in `&lt;main&gt;' 1: from /Users/iosdev/.rvm/rubies/ruby-2.5.3/lib/ruby/site_ruby/2.5.0/rubygems.rb:308:in `activate_bin_path'/Users/iosdev/.rvm/rubies/ruby-2.5.3/lib/ruby/site_ruby/2.5.0/rubygems.rb:289:in `find_spec_for_exe': can't find gem cocoapods (&gt;= 0.a) with executable pod (Gem::GemNotFoundException) 解决121 sudo gem update --system2 gem install cocoapods","tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://gezhenrong.cn/tags/CocoaPods/"}]},{"title":"命令Xcode自动打包","date":"2019-01-06T04:53:54.000Z","path":"2019/01/06/命令Xcode自动打包/","text":"命令Xcode自动打包 一、Xcode常用打包方式做过iOS的都应该知道，iOS打包方式 Product ——&gt;Archive ——&gt;Upload to AppStore 或者 Export 一个项目从打包到上传，基本上耗时10分钟以上，大的项目需要更长时间，这对于我们来说是很不方便的。如果通过命令脚本的方式自动打包，这种方式是很方便的快捷的。 二、自动打包配置流程目前Xcode9可以自动下载管理证书，不用我们自己去配置开发及生产证书。所以自动打包就省略配置证书步揍 通过命令到项目文件目录 下载shell脚本 将文件中的Archive文件拖入到项目中 修改脚本中的一下基本配置(项目名称，及debug模式，上传搭配Appstore需要填入相应的账号及密码) 执行脚本文件 sh shell.sh 三、打包图解流程首先通过二中连接进行下载脚本文件，并放到项目文件中 打开shell.sh脚本文件，修改相关配置 执行文件 我们常用窗口对Xcode进行操作时，Xcode原理是Xcode内部执行了Xcodebuild命令，统一放到脚本文件中，运行这个脚本文件，在执行下面的文件 四、脚本文件解读","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"},{"name":"总结","slug":"总结","permalink":"http://gezhenrong.cn/tags/总结/"}]},{"title":"对时间的归档","date":"2018-07-07T15:33:09.000Z","path":"2018/07/07/对时间的归档/","text":"获取iOS设备信息 1、获取当前日期、时间1234NSDate *currentDate = [NSDate date];NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@\"YYYY-MM-dd\"];NSString *currentDateStr = [dateFormatter stringFromDate:currentDate]; 2、获取一周前的日期、时间12345678NSDate * date = [NSDate date];NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@\"yyyy-MM-dd\"];//一周的秒数NSTimeInterval time = 7 * 24 * 60 * 60;//下周就把\"-\"去掉NSDate *lastWeek = [date dateByAddingTimeInterval:-time];NSString *startDate = [dateFormatter stringFromDate:lastWeek]; 3、比较两个日期大小123456789101112131415161718192021222324252627282930313233343536//比较两个日期大小-(int)compareDate:(NSString*)startDate withDate:(NSString*)endDate&#123;int comparisonResult;NSDateFormatter *formatter = [[NSDateFormatter alloc] init];[formatter setDateFormat:@\"yyyy-MM-dd\"];NSDate *date1 = [[NSDate alloc] init];NSDate *date2 = [[NSDate alloc] init];date1 = [formatter dateFromString:startDate];date2 = [formatter dateFromString:endDate];NSComparisonResult result = [date1 compare:date2];NSLog(@\"result==%ld\",(long)result);switch (result)&#123;//date02比date01大case NSOrderedAscending:comparisonResult = 1;break;//date02比date01小case NSOrderedDescending:comparisonResult = -1;break;//date02=date01case NSOrderedSame:comparisonResult = 0;break;default:NSLog(@\"erorr dates %@, %@\", date1, date2);break;&#125;return comparisonResult;&#125;int comparisonResult = [self compareDate:startDate withDate:endDate];if(comparisonResult &gt;0)&#123;//endDate 大&#125; 4、比较日期差123456789101112131415//比较两个日期大小-(NSInteger)compare:(NSDate *)startTime to:(NSDate *)endTime&#123;// 当前日历NSCalendar *calendar = [NSCalendar currentCalendar];// 需要对比的时间数据NSCalendarUnit unit = NSCalendarUnitYear | NSCalendarUnitMonth| NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond;// 对比时间差NSDateComponents *dateCom = [calendar components:unit fromDate:startTime toDate:endTime options:0];NSString *time = [NSString stringWithFormat:@\"%ld%ld%ld%ld%ld%ld\",dateCom.year,dateCom.month,dateCom.day,dateCom.hour,dateCom.minute,dateCom.second];NSLog(@\"time----&gt;%@\",time);return [time integerValue];&#125; 5、时间和时间戳的转换12345678910111213141516//获取系统时间戳NSDate* date1 = [NSDate date];NSTimeInterval time1 =[date1 timeIntervalSince1970];NSString *timeString = [NSString stringWithFormat:@\"%.0f\",time1];NSLog(@\"系统时间戳:%@\",timeString);//时间戳转换成时间NSTimeInterval time2 =[timeString doubleValue];NSDate *date2 = [NSDate dateWithTimeIntervalSince1970:time2];NSLog(@\"date2 = %@\",date2);NSDateFormatter *formatter = [[NSDateFormatter alloc]init];[formatter setDateFormat:@\"yyyy/MM/dd\"];NSString *currentTime = [formatter stringFromDate:date2];NSLog(@\"当前时间:%@\",currentTime);//时间转时间戳NSString *timeStr = [NSString stringWithFormat:@\"%.0f\",[date2 timeIntervalSince1970]];","tags":[{"name":"归档","slug":"归档","permalink":"http://gezhenrong.cn/tags/归档/"}]},{"title":"iOS9以上的系统判断设备上是否有安装某app","date":"2018-07-07T15:24:09.000Z","path":"2018/07/07/iOS9以上的系统判断设备上是否有安装某app/","text":"iOS9以上的系统判断设备上是否有安装某app 方法一： 步骤一： 获取iOS设备上所有已经安装的app 1234567-(void)getAllApp&#123;Class LSApplicationWorkspace_class = objc_getClass(\"LSApplicationWorkspace\");NSObject* workspace = [LSApplicationWorkspace_class performSelector:@selector(defaultWorkspace)];NSArray *allApplications = [workspace performSelector:@selector(allApplications)];//这样就能获取到手机中安装的所有AppNSLog(@\"设备上安装的所有app:%@\",allApplications);&#125; 打印出来的结果’： 1234567891011121314152017-01-17 15:16:27.562 TRCloundDocumnet[751:209420] 设备上安装的所有app:(\"&lt;LSApplicationProxy: 0x12e563310&gt; com.apple.Passbook &lt;file:///Applications/Passbook.app&gt;\",\"&lt;LSApplicationProxy: 0x12e563bb0&gt; com.apple.GameController &lt;file:///Applications/GameController.app&gt;\",\"&lt;LSApplicationProxy: 0x12e564230&gt; com.apple.managedconfiguration.MDMRemoteAlertService &lt;file:///Applications/MDMRemoteAlertService.app&gt;\",\"&lt;LSApplicationProxy: 0x12e5646f0&gt; com.apple.MailCompositionService &lt;file:///Applications/MailCompositionService.app&gt;\",\"&lt;LSApplicationProxy: 0x12e564bd0&gt; com.apple.calculator &lt;file:///Applications/Calculator.app&gt;\",\"&lt;LSApplicationProxy: 0x12e5651f0&gt; com.apple.SharedWebCredentialViewService &lt;file:///Applications/SharedWebCredentialViewService.app&gt;\",\"&lt;LSApplicationProxy: 0x12e5656f0&gt; com.apple.SafariViewService &lt;file:///Applications/SafariViewService.app&gt;\",\"&lt;LSApplicationProxy: 0x12e565c40&gt; com.apple.ios.StoreKitUIService &lt;file:///Applications/StoreKitUIService.app&gt;\",\"&lt;LSApplicationProxy: 0x12e566150&gt; com.apple.MobileStore &lt;file:///Applications/MobileStore.app&gt;\",\"&lt;LSApplicationProxy: 0x12e566bc0&gt; com.apple.tips &lt;file:///Applications/Tips.app&gt;\",\"&lt;LSApplicationProxy: 0x12e586400&gt; com.kingsoft.www.office.wpsoffice &lt;file:///private/var/containers/Bundle/Application/135D6955-A45F-4A3E-971A-B601757E96A7/wpsoffice.app&gt;\",\"&lt;LSApplicationProxy: 0x12e586c60&gt; com.tencent.mqq &lt;file:///private/var/containers/Bundle/Application/AD66793A-7E19-4F50-93EB-05FA736E5D78/QQ.app&gt;\",\"&lt;LSApplicationProxy: 0x12e587530&gt; jack.LQPhotoPickerDemo &lt;file:///private/var/containers/Bundle/Application/4C433042-7208-4E33-8544-AAAB6716E4F7/LQPhotoPickerDemo.app&gt;\" 步骤二：判断iOS设备上是否有安装某个app，判断依据是根据app 的Bundle Id。从打印结果看出，我们上一步所获取到的allApplications数组中的元素是一个LSApplicationProxy类型的，我们要把这个转换成字符串, 这个字符串中不只包含了App的bundle ID，还包含了安装的路径，因为这个路径不唯一不确定，我们判断是否安装了某个App只需判断这个字符串中的bundle ID，所有我们还要对字符串做处理。前提是要知道你要判断的这个app的Bundle ID 是什么 1234567891011121314151617-(void)isInstallLDApp:(NSArray *)allAPP&#123;NSInteger zlConnt = 0;for (NSString *appStr in allAPP) &#123;NSString *app = [NSString stringWithFormat:@\"%@\",appStr];//转换成字符串NSRange range = [app rangeOfString:@\"LdWBrowserIPhone\"];//是否包含这个bundle IDif (range.length &gt; 1)&#123;zlConnt ++;&#125;&#125;if (zlConnt &gt;= 1) &#123;NSLog(@\"已安装天锐绿盾\");&#125;else&#123;NSLog(@\"没有安装天瑞绿盾\");&#125;&#125; 方法一的优点： 完美解决iOS9的canopenurl 白名单的限制 ，缺点： 遍历的过程中可能会消耗性能， App Store审核可能会被拒，前提是要知道你要判断的这个app的Bundle ID 是什么 方法二： 步骤一：首先要知道你要判断的这款app的UrlSchemes 是什么备注： 1，获取app的 urlschemes 的方法把相应的 app 的 ipa 安装文件下载下来，把文件 .ipa 的后缀改成 .zip，然后解压，打开 Payload/xxx.app/Info.plist 这个文件，找到 URL types 下的 URL Schemes 下的数组对应的值就是这个 app 的 URL Scheme 了2，简单验证一个 URL Scheme 是否正确的方法：在真机设备（此设备要安装了待验证的 app）里面打开 Safari，然后在地址栏中键入该应用的 URL Scheme，后加 ://，比如 Weico 的，在地址栏中键入 weico:// ，然后点击确定，如果能正常调用出 Weico，即代表这个 URL Scheme 正确可用步骤二： 对于系统iOS 9来说，把需要检测的UrlScheme添加到白名单即可，添加方法：info.plist 增加LSApplicationQueriesSchemes （array类型），把要检测的app的UrlScheme加进去。 步骤三： 在代码中调用Application 的canopenUrl 的方法判断设备时候有对应的应用 程序，返回YES表示已安装了该app代码如下： 12345if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"IOSDevApp://\"]])&#123; //说明此设备有安装app｝else｛//说明此设备没有安装app｝ 方法二的优点： 效率高，代码量小 ，但前提是要先知道要判断的app 的UrlSchemes.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"App应用内地图跳转","date":"2018-06-16T03:26:40.000Z","path":"2018/06/16/App应用内地图跳转/","text":"","tags":[]},{"title":"iOS多图片下载","date":"2018-05-04T01:48:55.000Z","path":"2018/05/04/iOS多图片下载/","text":"iOS多图片下载 多图片下载对于图片下载我们一般都是使用第三方框架 SDWebImage原理是： 1.显示placeholderImage2.SDImageCache从缓存中查找图片是否已经下载3.先从内存图片缓存查找是否有图片4.如果内存中有图片缓存，显示图片5.如果内存中没有，生成NSInvocationOperation添加到执行队列开始从硬盘查找图片缓存6.如果硬盘中有，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存），显示图片7.如果硬盘中没有，说明该图片没有缓存，需要下载图片，共享或重新生成一个下载器SDWebImageDownLoader开始下载图片8.开始图片网络请求，下载数据9.数据下载完成后交给SDWebImageDecoder做图片解码10.回调展示图片11.图片保存到硬盘缓存和内存缓存12.SDImageCache初始化会注册一些通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片 下面我们根据第三方的思想，也去试着去做一下 SDWebImage思想1. 是建立缓存机制，不会让图片进行反复下载 2. 异步下载，可以放到子线程中进行，不会影响到主线程的操作 框架流程12345678910111213if (内存中有图片) &#123; 加载到主线程&#125;else&#123; if (沙盒中有缓存) &#123; 1，加载到主线程 2，保存一份到内存中 &#125;else&#123; 1，下载图片 2，加载到主线程 3，保存一份到内存中(以图片名字做key，image对象做value） 4，保存一份到沙盒中 &#125;&#125; 实现我们将图片加载到UITableViewCell中进行加载，同时可以避免重复下载造成卡顿 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //1,创建cell static NSString *ID = @\"cellId\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; //取出hero模型, ImageModel *model = self.dataSource[indexPath.row]; cell.textLabel.text = model.name; cell.textLabel.font = [UIFont systemFontOfSize:15]; cell.imageView.image = [UIImage imageWithData:@\"placeHold_image\"]; //取出英雄名字,先去缓存中找,没有再下载(下载完之后储存到内存中一份) NSString *nameStr = [model.name stringByReplacingOccurrencesOfString:@\"pic_Image\" withString:@\"\"]; UIImage *img = [self.picDict objectForKey:nameStr]; if (img) &#123; cell.imageView.image = img; &#125;else&#123; //去硬盘里找找看 //获得cache路径 NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; //拼接全路径 NSString *fullPath = [cachePath stringByAppendingString:nameStr]; NSData *data = [NSData dataWithContentsOfFile:fullPath]; if (data) &#123; //沙盒中有缓存 //1,加载到cell中 UIImage *image = [UIImage imageWithData:data]; cell.imageView.image = image; //2,保存一份到内存中 [self.picDict setObject:image forKey: nameStr]; &#125;else&#123; //沙盒中无缓存 //1,网络下载 [self download:app.icon indexPath:indexPath]; &#125; &#125; return cell;&#125; 图片下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 下载图片 * * @param imageUrl 图片的url */- (void)download:(NSString *)imageUrl indexPath:(NSIndexPath *)indexPath&#123; // 取出当前图片url对应的下载操作（operation对象） NSBlockOperation *operation = self.operations[imageUrl]; if (operation) return; // 创建操作，下载图片 __weak typeof(self) appsVc = self; operation = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:imageUrl]; NSData *data = [NSData dataWithContentsOfURL:url]; // 下载 UIImage *image = [UIImage imageWithData:data]; // NSData -&gt; UIImage // 回到主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; if (image) &#123; // 如果存在图片（下载完成），存放图片到图片缓存字典中 cell.images[imageUrl] = image; //将图片存入沙盒中 //1. 先将图片转化为NSData NSData *data = UIImagePNGRepresentation(image); //2. 再生成缓存路径 [data writeToFile:CachedImageFile(imageUrl) atomically:YES]; &#125; // 从字典中移除下载操作 (保证下载失败后，能重新下载) [cell.operations removeObjectForKey:imageUrl]; // 刷新当前表格，减少系统开销 [self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationNone]; &#125;]; &#125;]; // 添加下载操作到队列中 [self.queue addOperation:operation]; // 将当前下载操作添加到下载操作缓存中 (为了解决重复下载) self.operations[imageUrl] = operation;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"数据库操作","date":"2017-11-25T05:21:41.000Z","path":"2017/11/25/数据库操作/","text":"数据库操作 iOS目前我们常用到的数据库有FMDB、WCDB、cocoaData和Realm,我常用到的是FMDB、和WCDB，现在闲暇时间做一下总结。 FMDB 主要介绍FMDB是一个和iOS的SQLite数据库操作相关的第三方框架。主要把C语言操作数据库的代码用OC进行了封装。使用者只需调用该框架的API就能用来创建并连接数据库，创建表，查询等。 优点 1、轻量级，灵活。不消耗太多性能2、FMDB将C语言的iOS系统的SQLite数据库的操作代码用OC进行封装，面向对象，容易理解和使用3、提供了线程不安全的解决方案。 框架介绍 FMDatabase，一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句 FMResultSet 使用FMDatabase执行查询后的结果集 FMDatabaseQueue 用于在多线程中执行多个查询或更新，它是线程安全的 实践首先创建一个Model 首先我封装的demo中封装到单例中 1234567891011121314151617181920212223242526272829//创建表是否成功-(BOOL)openFMDBName:(NSString *)pathStr;/** * 增加 */-(BOOL)insetTitle:(id)model withPath:(NSString *)pathStr;/** * 删除 根据userid进行删除 */-(void)deleteWithTitle:(NSString *)pathStr withUserID:(NSString *)userId;/** * 删除所有数据 */-(void)deleteWithTitle:(NSString *)pathStr;/** * 更新数据 修改 */-(void)updateWithModel:(id)model;/** * 条件查询数据 */-(void)selectWithTitle:(NSString *)userId withUserID:(NSString *)pathStr;/** * 查询所有数据 * */-(void)selectAllMethod:(NSString *)pathStr withBlock:(void(^)(id Success))block;//查询数据(去除重复数据)-(NSArray *)queryDataWithTableName:(NSString *)pathStr keyword:(NSString *)keyword; 添加数据的时候，将汉字转化为拼音，在根据sql语句中like进行查找，做到本地搜索，查询。 WCDBWCDB是微信官方的移动端数据库组件，致力于提供一个高效、易用、完整的移动端存储方案。 优点 易用，WCDB支持一句代码即可将数据取出并组合为object。 WINQ(WCDB语言集成查询)：通过WINQ，开发者无须为了拼接SQL的字符串而写一大坨胶水代码。 ORM(Object Relational Mapping)：WCDB支持灵活、易用的ORM。开发者可以很便捷地定义表、索引、约束，并进行增删改查操作。 高效，WCDB通过框架层和sqlcipher源码优化，使其更高效的表现。 多线程高并发：WCDB支持多线程读与读、读与写并发执行，写与写串行执行。 框架介绍WCDB提供了三个基础类进行数据库操作：WCTDatabase、WCTTable、WCTTransaction WCTDatabase表示一个数据库，可以进行所有数据库操作，包括增删查改、表操作、事务、文件操作、损坏修复等。 对于同一个路径的数据库，不同的WCTDatabase、WCTTable、WCTTransaction对象共享同一个WCDB核心。因此，你可以在代码的不同位置、不同线程任意创建不同的基础类对象，WCDB会自动管理它们的共享数据和线程并发 实践 首先和FMDB一样建立model,定义相应的字段，及索引属性，主键等 利用宏定义绑定到表的类将一个已有的OC类进行QRM绑定的过程（WCTTableCoding），需要绑定到表中的字段在这里声明，在.mm中去绑定 3. 1234567891011121314151617181920212223242526//关闭数据库+(void)killDB;//添加数据- (BOOL)insertUser:(WCDModel*)mod;//更新所有的数据- (BOOL)updateUser:(WCDModel*)mod;//根据userid进行更新数据- (BOOL)updateAgeAndUserIDWithMod:(WCDModel*)mod;//通过model进行删除- (BOOL)deleteUser:(WCDModel*)mod;//删除所有- (BOOL)deleteAllUsers;//通过userid查询- (WCDModel *)getUserWithId:(NSString*)userID;//根据号查询- (NSArray*)getUsersWithTelNum:(NSInteger)telNum;//查询所有数据- (NSArray*)getAllUser; 注意 在你的代码文件头引入头文件#import 。 由于WCDB是基于Objective-C++，因此需要将引用WCDB的源文件后缀.m改为.mm。 DatabaseManagerDemo地址","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"},{"name":"总结","slug":"总结","permalink":"http://gezhenrong.cn/tags/总结/"}]},{"title":"iPhone X 设计适配指南和iOS 11 新特性","date":"2017-09-24T10:27:59.000Z","path":"2017/09/24/iPhone-X-设计适配指南和iOS-11-新特性/","text":"iPhone X 设计适配指南和iOS 11 新特性 iPhone X尺寸iPhone X 的屏幕宽度同 iPhone 6、iPhone 6s、iPhone 7 和 iPhone 8 的 4.7 英寸屏幕宽度相同，即 375pt。屏幕垂直高度增加了 145pt，这意味着增加了 20% 的可视空间。 竖屏规格：1125px × 2436px (375pt × 812pt @3x) 横屏规格：2436px × 1125px (812pt × 375pt @3x) 请为你的应用提供高分辨率的设计素材。iPhone X 有非常高的分辨率，请提供 @3x 的设计素材。对于图形类或其他扁平化图像素材，最好使用一倍尺寸下的 PDF 格式。 图像尺寸及分辨率 自定义图标 iphone手机适配标准 原生控件frame变化在iPhone X系统会自动修改StatusBar与Tabbar的高度，Tabbar从49pt变为83pt。StatusBar由20pt变为了44pt 举个例子。原生的Tabbar高度为49pt.当iPhone X时候自动变为了83pt，自动拉伸了34pt。有很多反人类但是必须得做的需求是，需要把tabbar。高度改为非原生值，比如改成写死值55. 这时候iPhonex 中就有问题了。所以要换个方法，不要写死值。要么加变化量。要么单独判断下。iPhone X不变高度。 812pt-667pt = 145pt，145pt-状态栏增加的20pt-tabbar增加的34pt = 91pt，意味着全使用原生bars的app，如果不是tableview那种页面。有91pt的空白距离要设计上来做处理。 启动图: 1125 * 2436 statusBar高度: 44 tabbar高度: 83 注意 注意：iPhone X 的导航栏高度为44， 状态栏高度44， Tabbar 高度83，叫UI设计师帮你切一张 1125x2436 的图，将原先项目Assets中的LaunchImage保存一下，新建一个LaunchImage，将原LaunchImage中的图拖回原位，然后将 1125x2436 的图放入 iPhone X Portrait iOS 11+ 的位置，如果你使用的是原生的Tabbar和导航控制器，此时基本已经适配完成 大家可能碰到 iPhone X 的模拟器打印 [UIScreen mainScreen].bounds.size.height 的值为 667 的问题这种问题就是 LaunchImage 中没有 iPhone X Portrait iOS 11+ 图片导致的，大家添加上，即可恢复正常 手势iPhone X 上的显示屏使用屏幕边缘手势来访问主屏幕、应用程序切换器、通知中心和控制中心。避免干扰系统范围的屏幕边缘手势。人们依靠这些手势在每个应用程序中工作。在极少数情况下，像游戏这样的沉浸式应用程序可能需要自定义的屏幕边缘手势，优先于系统的手势 - 第一个滑动会调用特定于应用的手势，而第二次滑动则会调用系统手势。这种行为（称为边缘保护）应该谨慎实施，因为它使得用户难以访问系统级的操作。 启动App对于一些老项目，在启动图上，可能没有采用xib或者SB进行适配的，所以可能会出现如图一，这样导致整个项目运行就会不能完全贴合。 解决办法，在项目设置里面直接用LaunchScreen.xib或者LaunchScreen.storyboard进行配置启动图，这样项目就会完整显示了 iOS 11 NavigationBar 新特性Navigation 集成 UISearchController把你的UISearchController赋值给navigationItem，就可以实现将UISearchController集成到Navigation。 12navigationItem.searchController //iOS 11 新增属性navigationItem.hidesSearchBarWhenScrolling //决定滑动的时候是否隐藏搜索框；iOS 11 新增属性 1@property (nonatomic, retain, nullable) UISearchController *searchController API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(tvos); iPhone X常用的宏定义判断iPhone X 1#define IS_IPHONEX (([[UIScreen mainScreen] bounds].size.height - 812) ? NO : YES) Tabbar默认高度 1#define kTabBarHeight ((IS_IPHONEX) ? 83 : 49) 状态栏默认高度 1#define kStatusBarHeight ((IS_IPHONEX) ? (44) : (20)) iOS11 UIScrollView and UITableView的新特性tableView cell高度问题和头视图尾视图会有很大间隙 这个应该是UITableView最大的改变。我们知道在iOS8引入Self-Sizing 之后，我们可以通过实现estimatedRowHeight相关的属性来展示动态的内容，实现了estimatedRowHeight属性后，得到的初始contenSize是个估算值，是通过estimatedRowHeight x cell的个数得到的，并不是最终的contenSize，tableView不会一次性计算所有的cell的高度了，只会计算当前屏幕能够显示的cell个数再加上几个，滑动时，tableView不停地得到新的cell，更新自己的contenSize，在滑到最后的时候，会得到正确的contenSize。 Self-Sizing在iOS11下是默认开启的，Headers, footers, and cells都默认开启Self-Sizing，所有estimated 高度默认值从iOS11之前的 0 改变为UITableViewAutomaticDimension： 如果目前项目中没有使用estimateRowHeight属性，在iOS11的环境下就要注意了，因为开启Self-Sizing之后，tableView是使用estimateRowHeight属性的，这样就会造成contentSize和contentOffset值的变化，如果是有动画是观察这两个属性的变化进行的，就会造成动画的异常，因为在估算行高机制下，contentSize的值是一点点地变化更新的，所有cell显示完后才是最终的contentSize值。因为不会缓存正确的行高，tableView reloadData的时候，会重新计算contentSize，就有可能会引起contentOffset的变化。iOS11下不想使用Self-Sizing的话，可以 通过以下方式关闭： 1234self.tableView.estimatedRowHeight = 0;self.tableView.estimatedSectionHeaderHeight = 0;self.tableView.estimatedSectionFooterHeight = 0;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS推送集成","date":"2017-07-23T15:51:18.000Z","path":"2017/07/23/iOS推送集成/","text":"iOS推送集成 极光集成推送需要注意选择1：根据域名配置在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。然后给它添加一个NSExceptionDomains，类型为字典类型；把需要的支持的域添加給NSExceptionDomains。其中jpush.cn作为Key，类型为字典类型。每个域下面需要设置2个属性：NSIncludesSubdomains、NSExceptionAllowsInsecureHTTPLoads。 为什么iOS收不到推送消息？如果你确认 appKey 在 SDK 客户端与 Portal 上设置是一致，其他环节也按照文档正确地操作。但还是收不到推送消息。那么，有一定的可能性，是你在 Portal 上上传的证书，不是 APNs (Push) 证书。推送时指定的iOS推送环境和应用证书是同一个环境。 上传到appStore的版本为什么收不到推送？请确认xcode选择的生产证书和上传的证书的bundleid一致；如果是在jpush网站上推送，请确认新建通知时推送对象是否选择了生产环境；如果是v3 api推送，请确认是否使用了apns_production参数，值是否为：true；如果没有使用apns_production参数请确认jpush网站上该应用的部署环境是否已经切换到生产环境。iOS 平台上传证书一直为未通过状态证书上传未通过的原因一般有： 密码错误；上传的apns证书环境不一致；上传到控制台必须是apns证书，非apns证书会带来错误，还有其他的原因可能是开发者证书也可能是apns证书那里导出来的私钥具体请看上传后显示的错误输出内容。 出现Not get deviceToken yet. Maybe: your certificate not configured APNs?…错误日志时如何排除问题?如果出现上述日志，则说明一段时间内都无法获取device token，那么： 确认你的app配置了apns权限，如果未配置apns权限，则应该会出现此错误提示。确认你的app运行在ios真机而非模拟器上，且通知中心中对应app的通知权限没有完全关闭（alert/sound/badge至少有一个权限是打开的）。确认你的网络状况，与apple的服务器的连接是通过tcp的 5223端口连接，确认你网络的对应端口是否可用，可通过下列命令来确认这点： 百度集成推送当我们创建证书之后需要将证书添加到百度网站上，我们导出的证书p12文件，我们需要转换为pem证书 1openssl pkcs12 -in MyApnsCert.p12 -out MyApnsCert.pem -nodes 提示需要输入密码，输入刚才导出 p12 时的密码即可。 注意 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{ //服务端推送的badge是几就会显示几,你只需要跟服务端同步消息数目，然后让服务端自己，该推送几，就推送几,比如你应用打开的时候，或者进入后台的时候跟服务端同步，这个点，需要你们自己去设计，应用没有消息的时候，服务端推送了1，当应用打开时候，告诉服务端，app没点击通知，那下次应用推送2,依次类推。 if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 8.0) { UIUserNotificationType myTypes = UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:myTypes categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; }else { UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeSound; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes]; } // 测试 开发环境 时需要修改BPushMode为BPushModeDevelopment 需要修改Apikey为自己的Apikey // 在 App 启动时注册百度云推送服务，需要提供 Apikey [BPush registerChannel:launchOptions apiKey:@\"Apikey改成自己的\" pushMode:BPushModeDevelopment withFirstAction:nil withSecondAction:nil withCategory:nil isDebug:YES]; // App 是用户点击推送消息启动 NSDictionary *userInfo = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; if (userInfo) { NSLog(@\"从消息启动:%@\",userInfo); [BPush handleNotification:userInfo]; } [[UIApplication sharedApplication] setApplicationIconBadgeNumber:0];//角标清0 } 需要注意时，开发状态下 BPushModeDevelopment 发布状态下是，BPushModeProduct,不然收不到消息","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"ReactiveCocoa上手","date":"2017-06-21T09:31:05.000Z","path":"2017/06/21/ReactiveCocoa上手/","text":"ReactiveCocoa函数响应式编程 ReactiveCocoa简介由Github 开源的一个应用于iOS和OS X开发的新框架ReactiveCocoa为事件定义了一个标准接口，iOS 开发中有着各种消息传递机制，包括 KVO、Notification、delegation、block 以及 target-action 方式本质上RACObserve使用了KVO来监听property的变化，只要username被自己或外部改变，block就会被执行。但不是所有的property都可以被RACObserve，该property必须支持KVOReactiveCocoa ，就是用信号接管了iOS 中的所有事件；也就意味着，用一种统一的方式来处理iOS中的所有事件，解决了各种分散的事件处理方式，显然这么一个庞大的框架学习起来也会比较难！而且如果习惯了iOS原生的编程，可能会觉得不习惯！ 函数式编程（Functional Programming）：使用高阶函数，例如函数用其他函数作为参数。 响应式编程（Reactive Programming）：关注于数据流和变化传播。 ReactiveCocoa的使用KVO123[RACObserve(self, username) subscribeNext:^(id x) &#123; NSLog(@\" 成员变量 username 被修改成了：%@\", x);&#125;]; target-action12345678910111213141516171819202122232425262728293031323334353637383940button添加事件button.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@\" 按钮被点击 \"); return [RACSignal empty];&#125;];//or__weak typeof(self) weakSelf = self;@weakify(self)[[button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; @strongify(self); NSLog(@\"123444\"); &#125; ];//文本事件监听@weakify(self);[[self.nameText rac_textSignal] subscribeNext:^(id x) &#123; @strongify(self); NSLog(@\"%@\",x); self.person.name = x; &#125;];//组合信号监听 id signals = @[[self.nameText rac_textSignal],[self.passWordText rac_textSignal]];@weakify(self);[[RACSignal combineLatest:signals] subscribeNext:^(RACTuple *x) &#123; @strongify(self); NSString *name = [x first]; NSString *password = [x second]; if (name.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123; self.loginButton.enabled = YES; self.nameT.name = name; self.passT.password = password; &#125; else &#123; self.loginButton.enabled = NO; &#125; &#125;]; Notification1234567[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@\"注册名称\" object:nil] subscribeNext:^(id x) &#123; NSLog(@\" 键盘 Frame 改变 \"); &#125; ]; Delegate123[[self rac_signalForSelector:@selector(viewWillAppear:)] subscribeNext:^(id x) &#123; NSLog(@\"viewWillAppear 方法被调用 %@\", x);&#125;]; ReactiveCocoa的特点ReactiveCocoa 优点传统 iOS 开发过程中，状态以及状态之间依赖过多的问题传统 MVC 架构的问题：Controller 比较复杂，可测试性差提供统一的消息传递机制 对于传统的 Model-View-Controller 的框架，Controller 很容易变得比较庞大和复杂。由于 Controller 承担了 Model 和 View 之间的桥梁作用，所以 Controller 常常与对应的 View 和 Model 的耦合度非常高，这同时也造成对其做单元测试非常不容易，对 iOS 工程的单元测试大多都只在一些工具类或与界面无关的逻辑类中进行。 ReactiveCocoa与MVVM关联RAC 的信号机制很容易将某一个 Model 变量的变化与界面关联，所以非常容易应用 Model-View-ViewModel 框架。通过引入 ViewModel 层，然后用 RAC 将 ViewModel 与 View 关联，View 层的变化可以直接响应 ViewModel 层的变化，这使得 Controller 变得更加简单，由于 View 不再与 Model 绑定，也增加了 View 的可重用性。 ReactiveCocoa 注意 通过 block 函数式 + 链式 的编程，可以让所有相关的代码继承在一起！ RAC 在应用中大量使用了 block，由于 Objective-C 语言的内存管理是基于 引用计数 的，为了避免循环引用问题，在 block 中如果要引用 self，需要使用@weakify(self)和@strongify(self)来避免强引用； @weakify(self); // 定义了一个weak的selfweak变量@strongify(self); // 局域定义了一个strong的self指针指向self_weak 12345678910#define weakify(...) \\\\autoreleasepool &#123;&#125; \\\\metamacro_foreach_cxt(rac_weakify_,, __weak, __VA_ARGS__)#define strongify(...) \\\\try &#123;&#125; @finally &#123;&#125; \\\\_Pragma(\"clang diagnostic push\") \\\\_Pragma(\"clang diagnostic ignored \\\\\"-Wshadow\\\\\"\") \\\\metamacro_foreach(rac_strongify_,, __VA_ARGS__) \\\\_Pragma(\"clang diagnostic pop\") 学习资料唐巧袁峥Seemygo","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS layoutSubView的使用","date":"2017-06-20T04:14:44.000Z","path":"2017/06/20/iOS-layoutSubView的使用/","text":"iOS layoutSubView的使用 layoutSubViews介绍UIView的setNeedsDisplay和setNeedsLayout方法。首先两个方法都是异步执行的。setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。 综上两个方法都是异步执行的，layoutSubviews方便数据计算，drawRect方便视图重绘 layoutSubViews相关方法123456- (void)layoutSubviews- (void)layoutIfNeeded- (void)setNeedsLayout——————–- (void)setNeedsDisplay- (void)drawRect layoutSubViews调用 什么时候进行调用 init初始化不会触发layoutSubviews。 addSubview会触发layoutSubviews。 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。 滚动一个UIScrollView会触发layoutSubviews。 旋转Screen会触发父UIView上的layoutSubviews事件。 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。 直接调用setLayoutSubviews。 直接调用setNeedsLayout。 刷新子对象布局 -layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写。-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用。-layoutIfNeeded方法：如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）。如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局。在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded] drawRect调用 1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用(drawRect 掉用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View)。c2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。sizeToFit会自动调用sizeThatFits方法。3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect: 注意点 1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。 2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制 drawRect与layoutSubViews的区别 layoutSubviews对subviews重新布局.layoutSubviews方法调用先于drawRect.如果view的frame值为0,即使被添加了耶不会调用layoutSubviews.drawRect是对receiver的重绘，能获得context.setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"App跳转到系统设置WI-FI设置","date":"2017-06-06T10:21:52.000Z","path":"2017/06/06/App跳转到系统设置WI-FI设置/","text":"App跳转到系统设置WI-FI设置 添加如下代码就可以了12345678NSString * urlString = @\"App-Prefs:root=WIFI\";if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:urlString]]) &#123; if ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 10.0) &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString] options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]]; &#125;&#125; 类似也有跳转到以下： 无线局域网 App-Prefs:root=WIFI 蓝牙 App-Prefs:root=Bluetooth 蜂窝移动网络 App-Prefs:root=MOBILE_DATA_SETTINGS_ID 个人热点 App-Prefs:root=INTERNET_TETHERING 运营商 App-Prefs:root=Carrier 通知 App-Prefs:root=NOTIFICATIONS_ID 通用 App-Prefs:root=General 通用-关于本机 App-Prefs:root=General&amp;path=About 通用-键盘 App-Prefs:root=General&amp;path=Keyboard 通用-辅助功能 App-Prefs:root=General&amp;path=ACCESSIBILITY 通用-语言与地区 App-Prefs:root=General&amp;path=INTERNATIONAL 通用-还原 App-Prefs:root=Reset 墙纸 App-Prefs:root=Wallpaper Siri App-Prefs:root=SIRI 隐私 App-Prefs:root=Privacy Safari App-Prefs:root=SAFARI 音乐 App-Prefs:root=MUSIC 音乐-均衡器 App-Prefs:root=MUSIC&amp;path=com.apple.Music:EQ 照片与相机 App-Prefs:root=Photos FaceTime App-Prefs:root=FACETIME 只需要把对应的字符串换一下就可以了。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":" iOS沙盒路径","date":"2017-06-01T10:36:30.000Z","path":"2017/06/01/iOS沙盒路径/","text":"iOS沙盒路径 1、模拟器沙盒目录文件都在个人用户名文件夹下的一个隐藏文件夹里，中文叫资源库，他的目录其实是Library。 因为应用是在沙箱（sandbox）中的，在文件读写权限上受到限制，只能在几个目录下读写文件：Documents：应用中用户数据可以放在这里，iTunes备份和恢复的时候会包括此目录tmp：存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除Library/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除 查看方法：方法1、可以设置显示隐藏文件，然后在Finder下直接打开。设置查看隐藏文件的方法如下：打开终端，输入命名(1)显示Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool true(2)隐藏Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool false(3)输完单击Enter键，退出终端，重新启动Finder就可以了 重启Finder：鼠标单击窗口左上角的苹果标志–&gt;强制退出–&gt;Finder–&gt;现在能看到资源库文件夹了。打开资源库后找到/Application Support/iPhone Simulator/文件夹。这里面就是模拟器的各个程序的沙盒目录了。方法2、这种方法更方便，在Finder上点-&gt;前往-&gt;前往文件夹，输入/Users/username/Library/Application Support/iPhone Simulator/ 前往。username这里写用户名。 NSKeyedArchiver（归档）：采用归档的形式来保存数据，该数据对象需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法。前一个方法告诉系统怎么对对象进行编码，而后一个方法则是告诉系统怎么对对象进行解码。例如对Possession对象归档保存。 1234567891011121314151617181920定义Possession：@interface Possession：NSObject&lt;NSCoding&gt;&#123;//遵守NSCoding协议NSString *name;//待归档类型&#125;@implementation Possession-(void)encodeWithCoder:(NSCoder *)aCoder&#123;[aCoder encodeObject:name forKey:@\"name\"];&#125;-(void)initWithCoder:(NSCoder *)aDecoder&#123;name=[[aDeCoder decodeObjectforKey:@\"name\"] retain];&#125;归档操作：如果对Possession对象allPossession归档保存，只需要NSCoder子类NSKeyedArchiver的方法archiveRootObject:toFile: 即可。NSString *path = [self possessionArchivePath];[NSKeyedArchiver archiveRootObject:allPossessions toFile: path ]解压操作：同样调用NSCoder子类NSKeyedArchiver的方法unarchiveRootObject:toFile: 即可 allPossessions = [[NSKeyedUnarchiver unarchiveObjectWithFile:path] retain]; 缺点：归档的形式来保存数据，只能一次性归档保存以及一次性解压。所以只能针对小量数据，而且对数据操作比较笨拙，即如果想改动数据的某一小部分，还是需要解压整个数据或者归档整个数据。 NSUserDefaults：用来保存应用程序设置和属性、用户保存的数据。用户再次打开程序或开机后这些数据仍然存在。NSUserDefaults可以存储的数据类型包括：NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary。如果要存储其他类型，则需要转换为前面的类型，才能用NSUserDefaults存储 SQLite：采用SQLite数据库来存储数据。SQLite作为一中小型数据库，应用ios中，跟前三种保存方式相比，相对比较复杂一些 注意：写入数据库，字符串可以采用char方式，而从数据库中取出char类型，当char类型有表示中文字符时，会出现乱码。这是因为数据库默认使用ascII编码方式。所以要想正确从数据库中取出中文，需要用NSString来接收从数据库取出的字符串","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS GCD并发编程","date":"2017-05-24T03:39:33.000Z","path":"2017/05/24/iOS并发编程/","text":"iOS并发编程 在 iOS 开发中，我们主要可以通过 Operation Queues、Dispatch Queues 和 Dispatch Sources 来提高应用的并发性,需要做的就是尽可能地提高应用的并发性，来充分利用这些多核心 CPU 的性能 进程: 指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程。另外，当一个进程的主线程退出时，这个进程就结束了 线程: 指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 POSIX threads API 的，也就是我们常说的 pthreads 任务: 指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码 串行 – 并发队列的特点：先进先出，排在前面的任务最先执行.从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。串行，指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；并发，则指的是允许多个任务同时执行,并发功能只有在异步（dispatch_async）函数下才有效。 同步 – 异步同样的，同步和异步操作的主要区别在于是否等待操作执行完成，亦即是否阻塞当前线程。同步操作会等待操作执行完成后再继续执行接下来的代码，而异步操作则恰好相反，它会在调用后立即返回，不会等待操作的执行结果。同步执行（dispatch_sync）：只能在当前线程中执行任务，不具备开启新线程的能力异步执行（dispatch_async）：可以在新的线程中执行任务，具备开启新线程的能力 队列 – 线程在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。 NSOperation有两个常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但是是后者使用Block形式进行代码组织，使用相对方便。 GCD：是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务GCD的其他方法： GCD的栅栏方法dispatch_barrier_async GCD的延时执行方法dispatch_after GCD的一次性代码(只执行一次)dispatch_once GCD的快速迭代方法dispatch_apply GCD的队列组dispatch_group 创建一个队列（串行队列或并发队列） 将任务添加到队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行） 队列的创建方法 可以使用dispatch_queue_create来创建对象，需要传入两个参数， 第一个参数表示队列的唯一标识符，用于DEBUG，可为空； 第二个参数用来识别是串行队列还是并发队列。DISPATCH_QUEUE_SERIAL表示串行队列，DISPATCH_QUEUE_CONCURRENT表示并发队列 1234// 串行队列的创建方法dispatch_queue_t queue= dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL);// 并发队列的创建方法dispatch_queue_t queue= dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT); 3. 对于并发队列，还可以使用dispatch_get_global_queue来创建全局并发队列。GCD默认提供了全局的并发队列，需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可 任务的创建方法 12345678// 同步执行任务创建方法dispatch_sync(queue, ^&#123; NSLog(@\"%@\",[NSThread currentThread]); // 这里放任务代码&#125;);// 异步执行任务创建方法dispatch_async(queue, ^&#123; NSLog(@\"%@\",[NSThread currentThread]); // 这里放任务代码&#125;); 虽然使用GCD只需两步，但是既然我们有两种队列，两种任务执行方式，那么我们就有了四种不同的组合方式。这四种不同的组合方式是 并发队列 + 同步执行并发队列 + 异步执行串行队列 + 同步执行串行队列 + 异步执行 实际上，我们还有一种特殊队列是主队列 主队列 + 同步执行主队列 + 异步执行 主队列：专门用来在主线程调度任务的队列，所以主队列的任务都要在主线程来执行，主队列会随着程序的启动一起创建，我们只需get即可全局队列：是系统为了方便程序员开发提供的，其工作表现与并发队列一致 GCD实现原理GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用胡话，这个线程就会被销毁 并发队列 + 同步执行 不会开启新线程，执行完一个任务，再执行下一个任务 123456789101112131415161718192021- (void) syncConcurrent&#123; NSLog(@\"syncConcurrent---begin\"); dispatch_queue_t queue= dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"syncConcurrent---end\");&#125; 输出结果：2016-09-03 19:22:27.577 GCD[11557:1897538] &gt;syncConcurrent—begin2016-09-03 19:22:27.578 GCD[11557:1897538] 1——{number = 1, name = main}2016-09-03 19:22:27.578 GCD[11557:1897538] 1——{number = 1, name = main}2016-09-03 19:22:27.578 GCD[11557:1897538] 2——{number = 1, name = main}2016-09-03 19:22:27.579 GCD[11557:1897538] 2——{number = 1, name = main}2016-09-03 19:22:27.579 GCD[11557:1897538] 3——{number = 1, name = main}2016-09-03 19:22:27.579 GCD[11557:1897538] 3——{number = 1, name = main}2016-09-03 19:22:27.579 GCD[11557:1897538] syncConcurrent—end 从并发队列 + 同步执行中可以看到，所有任务都是在主线程中执行的。由于只有一个线程，所以任务只能一个一个执行。 同时我们还可以看到，所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。 并发队列 + 异步执行可同时开启多线程，任务交替执行 123456789101112131415161718192021- (void) asyncConcurrent&#123; NSLog(@\"asyncConcurrent---begin\"); dispatch_queue_t queue= dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"asyncConcurrent---end\");&#125; 输出结果：2016-09-03 19:27:31.503 GCD[11595:1901548] asyncConcurrent—begin2016-09-03 19:27:31.504 GCD[11595:1901548] asyncConcurrent—end2016-09-03 19:27:31.504 GCD[11595:1901626] 1——{number = 2, name = (null)}2016-09-03 19:27:31.504 GCD[11595:1901625] 2——{number = 4, name = (null)}2016-09-03 19:27:31.504 GCD[11595:1901855] 3——{number = 3, name = (null)}2016-09-03 19:27:31.504 GCD[11595:1901626] 1——{number = 2, name = (null)}2016-09-03 19:27:31.504 GCD[11595:1901625] 2——{number = 4, name = (null)}2016-09-03 19:27:31.505 GCD[11595:1901855] 3——{number = 3, name = (null)} 在并发队列 + 异步执行中可以看出，除了主线程，又开启了3个线程，并且任务是交替着同时执行的。 另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始异步执行。 串行队列 + 同步执行不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务 123456789101112131415161718192021- (void) syncSerial&#123; NSLog(@\"syncSerial---begin\"); dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"syncSerial---end\");&#125; 输出结果为：2016-09-03 19:29:00.066 GCD[11622:1903904] syncSerial—begin2016-09-03 19:29:00.067 GCD[11622:1903904] 1——{number = 1, name = main}2016-09-03 19:29:00.067 GCD[11622:1903904] 1——{number = 1, name = main}2016-09-03 19:29:00.067 GCD[11622:1903904] 2——{number = 1, name = main}2016-09-03 19:29:00.067 GCD[11622:1903904] 2——{number = 1, name = main}2016-09-03 19:29:00.067 GCD[11622:1903904] 3——{number = 1, name = main}2016-09-03 19:29:00.068 GCD[11622:1903904] 3——{number = 1, name = main}2016-09-03 19:29:00.068 GCD[11622:1903904] syncSerial—end 在串行队列 + 同步执行可以看到，所有任务都是在主线程中执行的，并没有开启新的线程。而且由于串行队列，所以按顺序一个一个执行。 同时我们还可以看到，所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。 串行队列 + 异步执行会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务 123456789101112131415161718192021- (void) asyncSerial&#123; NSLog(@\"asyncSerial---begin\"); dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"asyncSerial---end\");&#125; 输出结果为：2016-09-03 19:30:08.363 GCD[11648:1905817] asyncSerial—begin2016-09-03 19:30:08.364 GCD[11648:1905817] asyncSerial—end2016-09-03 19:30:08.364 GCD[11648:1905895] 1——{number = 2, name = (null)}2016-09-03 19:30:08.364 GCD[11648:1905895] 1——{number = 2, name = (null)}2016-09-03 19:30:08.364 GCD[11648:1905895] 2——{number = 2, name = (null)}2016-09-03 19:30:08.364 GCD[11648:1905895] 2——{number = 2, name = (null)}2016-09-03 19:30:08.365 GCD[11648:1905895] 3——{number = 2, name = (null)}2016-09-03 19:30:08.365 GCD[11648:1905895] 3——{number = 2, name = (null)}在串行队列 + 异步执行可以看到，开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。 主队列 + 同步执行互等卡住不可行(在主线程中调用) 123456789101112131415161718192021- (void)syncMain&#123; NSLog(@\"syncMain---begin\"); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"syncMain---end\");&#125; 输出结果2016-09-03 19:32:15.356 GCD[11670:1908306] syncMain—begin 这时候，我们惊奇的发现，在主线程中使用主队列 + 同步执行，任务不再执行了，而且syncMain—end也没有打印。这是为什么呢？ 这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在正在处理syncMain方法，所以任务需要等syncMain执行完才能执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。 要是如果不再主线程中调用，而在其他线程中调用会如何呢？不会开启新线程，执行完一个任务，再执行下一个任务（在其他线程中调用） 1234dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123; [self syncMain];&#125;); 输出结果：2016-09-03 19:32:45.496 GCD[11686:1909617] syncMain—begin2016-09-03 19:32:45.497 GCD[11686:1909374] 1——{number = 1, name = main}2016-09-03 19:32:45.498 GCD[11686:1909374] 1——{number = 1, name = main}2016-09-03 19:32:45.498 GCD[11686:1909374] 2——{number = 1, name = main}2016-09-03 19:32:45.498 GCD[11686:1909374] 2——{number = 1, name = main}2016-09-03 19:32:45.499 GCD[11686:1909374] 3——{number = 1, name = main}2016-09-03 19:32:45.499 GCD[11686:1909374] 3——{number = 1, name = main}2016-09-03 19:32:45.499 GCD[11686:1909617] syncMain—end 在其他线程中使用主队列 + 同步执行可看到：所有任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个执行。同时我们还可以看到，所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。 主队列 + 异步执行主队列 + 异步执行 123456789101112131415161718192021- (void)asyncMain&#123; NSLog(@\"asyncMain---begin\"); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"asyncMain---end\");&#125; 输出结果：2016-09-03 19:33:54.995 GCD[11706:1911313] asyncMain—begin2016-09-03 19:33:54.996 GCD[11706:1911313] asyncMain—end2016-09-03 19:33:54.996 GCD[11706:1911313] 1——{number = 1, name = main}2016-09-03 19:33:54.997 GCD[11706:1911313] 1——{number = 1, name = main}2016-09-03 19:33:54.997 GCD[11706:1911313] 2——{number = 1, name = main}2016-09-03 19:33:54.997 GCD[11706:1911313] 2——{number = 1, name = main}2016-09-03 19:33:54.997 GCD[11706:1911313] 3——{number = 1, name = main}2016-09-03 19:33:54.997 GCD[11706:1911313] 3——{number = 1, name = main} 我们发现所有任务都在主线程中，虽然是异步执行，具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。 GCD线程之间的通讯在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; // 回到主线程 dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@\"2-------%@\",[NSThread currentThread]); &#125;);&#125;); 输出结果：2016-09-03 19:34:59.165 GCD[11728:1913039] 1——0x7f8319c06820&gt;{number = 2, name = (null)}2016-09-03 19:34:59.166 GCD[11728:1913039] 1——{number = 2, name = (null)}2016-09-03 19:34:59.166 GCD[11728:1912961] 2——-{number = 1, name = main} 可以看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。 GCD的其他方法 GCD的栅栏方法 dispatch_barrier_async我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。 12345678910111213141516171819- (void)barrier&#123; dispatch_queue_t queue = dispatch_queue_create(\"12312312\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSLog(@\"----1-----%@\", [NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@\"----2-----%@\", [NSThread currentThread]); &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@\"----barrier-----%@\", [NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@\"----3-----%@\", [NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@\"----4-----%@\", [NSThread currentThread]); &#125;);&#125; 输出结果：2016-09-03 19:35:51.271 GCD[11750:1914724] —-1—–{number = 2, name = (null)}2016-09-03 19:35:51.272 GCD[11750:1914722] —-2—–{number = 3, name = (null)}2016-09-03 19:35:51.272 GCD[11750:1914722] —-barrier—–{number = 3, name = (null)}2016-09-03 19:35:51.273 GCD[11750:1914722] —-3—–{number = 3, name = (null)}2016-09-03 19:35:51.273 GCD[11750:1914724] —-4—–{number = 2, name = (null)} 可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。 GCD的延时执行方法 dispatch_after当我们需要延迟执行一段代码时，就需要用到GCD的dispatch_after方法。 1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 2秒后异步执行这里的代码... NSLog(@\"run-----\");&#125;); GCD的一次性代码(只执行一次) dispatch_once 我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的dispatch_once方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // 只执行1次的代码(这里面默认是线程安全的)&#125;); GCD的快速迭代方法 dispatch_apply 通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法dispatch_apply，使我们可以同时遍历。比如说遍历0~5这6个数字，for循环的做法是每次取出一个元素，逐个遍历。dispatch_apply可以同时遍历多个数字。 1234dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_apply(6, queue, ^(size_t index) &#123; NSLog(@\"%zd------%@\",index, [NSThread currentThread]);&#125;); 从输出结果中前边的时间中可以看出，几乎是同时遍历的。 GCD的队列组 dispatch_group 有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行操作。这时候我们可以用到GCD的队列组。 * 我们可以先把任务放到队列中，然后将队列放入队列组中。 * 调用队列组的dispatch_group_notify回到主线程执行操作。 12345678910dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 执行1个耗时的异步操作&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 执行1个耗时的异步操作&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步操作都执行完毕后，回到主线程...&#125;); iOS多线程 iOS多线程开发 IOS多线程开发其实很简单","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS中图片圆角处理","date":"2017-05-20T08:06:39.000Z","path":"2017/05/20/iOS中图片圆角处理/","text":"iOS中图片圆角处理 方法一：使用layer 12_imageView.clipsToBounds=YES;_imageView.layer.cornerRadius=4.0; 效果：在图片较多的TableView里面，卡顿现象较明显，原因是离屏幕渲染消耗性能 方法二：贝塞尔曲线”切割”个这个图片，实现UIImage的扩展，将原图裁剪成圆角将方法定义在image类扩展中 12345678910111213141516171819-(UIImage *)roundedCornerImageWithCornerRadius:(CGFloat)cornerRadius&#123; CGFloat w = self.size.width; CGFloat h = self.size.width; CGFloat scale = [UIScreen mainScreen].scale; //防止圆角半径小于0，或者大于宽/高中较小的一半 if (cornerRadius &lt; 0) &#123; cornerRadius = 0; &#125;else if (cornerRadius &gt; MIN(w, h))&#123; cornerRadius = MIN(w, h)/2.; &#125; UIImage *image = nil; CGRect imageFrame = CGRectMake(0., 0., w, h); UIGraphicsBeginImageContextWithOptions(self.size, NO, scale); [[UIBezierPath bezierPathWithRoundedRect:imageFrame cornerRadius:cornerRadius] addClip]; [self drawInRect:imageFrame]; image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 方法使用image.image = [image roundedCornerImageWithCornerRadius:100];效果：在IPhone5s IPhone6上效果好一些，但是在IPhone6s上效果不太明显 方法三：将方法定义在图片剪切中,给当前image绘制圆角 12345678910111213141516171819-(UIImage *)roundedCornerImageWithCornerRadius:(CGFloat)cornerRadius&#123; CGFloat w = self.size.width; CGFloat h = self.size.width; CGFloat scale = [UIScreen mainScreen].scale; //防止圆角半径小于0，或者大于宽/高中较小的一半 if (cornerRadius &lt; 0) &#123; cornerRadius = 0; &#125;else if (cornerRadius &gt; MIN(w, h))&#123; cornerRadius = MIN(w, h)/2.; &#125; UIImage *image = nil; CGRect imageFrame = CGRectMake(0., 0., w, h); UIGraphicsBeginImageContextWithOptions(self.size, NO, scale); [[UIBezierPath bezierPathWithRoundedRect:imageFrame cornerRadius:cornerRadius] addClip]; [self drawInRect:imageFrame]; image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 方法使用image.image = [image roundedCornerImageWithCornerRadius:100];效果：效果较为明显，卡顿现象基本感觉不到 方法四：通过绘图技术来实现，给当前image绘制圆角将方法定义在image类扩展中 12345678910111213141516171819- (UIImage *)circleImage &#123; // 开始图形上下文 UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0); // 获得图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 设置一个范围 CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); // 根据一个rect创建一个椭圆 CGContextAddEllipseInRect(ctx, rect); // 裁剪 CGContextClip(ctx); // 将原照片画到图形上下文 [self drawInRect:rect]; // 从上下文上获取剪裁后的照片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 关闭上下文 UIGraphicsEndImageContext(); return newImage;&#125; 使用： 1UIImage *placeHolder = [[UIImage imageNamed:@\"defaultUserIcon\"] circleImage]; 效果：drawRect方法依赖Core Graphics框架来进行自定义的绘制缺点：它处理touch事件时每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例，那就会很糟糕了","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"Cocoa框架中的NSPredicate用于查询","date":"2017-05-19T00:52:19.000Z","path":"2017/05/19/Cocoa框架中的NSPredicate用于查询/","text":"Cocoa框架中的NSPredicate用于查询 Cocoa框架中的NSPredicate用于查询，原理和用法都类似于SQL中的where，作用相当于数据库的过滤取 pragma mark Predicate 的通配 123456789101112- (void)testPredicateWildcard&#123; /(5)通配符：LIKE 例：@\"name LIKE[cd] 'er'\" // 代表通配符,Like也接受[cd]. @\"name LIKE[cd] '???er'\" / NSArray placeArray = [NSArray arrayWithObjects:@\"Shanghai\",@\"Hangzhou\",@\"Beijing\",@\"Macao\",@\"Taishan\", nil]; NSPredicate predicate = [NSPredicate predicateWithFormat:@\"SELF like 'ai' \"]; NSArray tempArray = [placeArray filteredArrayUsingPredicate:predicate]; [tempArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL _Nonnull stop) &#123; NSLog(@\"obj == %@\",obj); &#125;]; pragma mark Predicate 字符串相关：BEGINSWITH、ENDSWITH、CONTAINS 123456789101112131415- (void)testPredicateRelateToNSString&#123; / (4)字符串相关：BEGINSWITH、ENDSWITH、CONTAINS 例：@\"name CONTAIN[cd] 'ang'\" //包含某个字符串 @\"name BEGINSWITH[c] 'sh'\" //以某个字符串开头 @\"name ENDSWITH[d] 'ang'\" //以某个字符串结束 注:[c]不区分大小写[d]不区分发音符号即没有重音符号[cd]既不区分大小写，也不区分发音符号。 / NSArray placeArray = [NSArray arrayWithObjects:@\"Shanghai\",@\"Hangzhou\",@\"Beijing\",@\"Macao\",@\"Taishan\", nil]; NSPredicate predicate = [NSPredicate predicateWithFormat:@\"SELF CONTAINS [cd] 'an' \"]; // NSPredicate predicate1 = [NSPredicate predicateWithFormat:@\"SELF Beginswith [cd] 'sh' \"]; NSArray tempArray = [placeArray filteredArrayUsingPredicate:predicate]; [tempArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSLog(@\"obj == %@\",obj); &#125;];&#125; pragma mark Predicate 与自身相比的功能 1234567891011- (void)testPredicateComparationToSelf&#123; / (3)字符串本身:SELF 例：@“SELF == ‘APPLE’\" / NSArray placeArray = [NSArray arrayWithObjects:@\"Shanghai\",@\"Hangzhou\",@\"Beijing\",@\"Macao\",@\"Taishan\", nil];NSPredicate predicate = [NSPredicate predicateWithFormat:@\"SELF == 'Beijing'\"]; NSArray tempArray = [placeArray filteredArrayUsingPredicate:predicate]; [tempArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL _Nonnull stop) &#123; NSLog(@\"obj == %@\",obj); &#125;];&#125; pragma mark Predicate范围运算功能 123456789101112131415- (void)testPredicateRange&#123; / (2)范围运算符：IN、BETWEEN 例：@\"number BETWEEN &#123;1,5&#125;\" @\"address IN &#123;'shanghai','beijing'&#125;\" /// NSArray array = [NSArray arrayWithObjects:@1,@2,@3,@4,@5,@2,@6, nil]; NSArray array = [NSArray arrayWithObjects:@\"shanghai\",@\"beijing\", nil]; //NSPredicate predicate = [NSPredicate predicateWithFormat:@\"SELF in &#123;2,5&#125;\"]; 找到 in 的意思是array中&#123;2,5&#125;的元素 NSPredicate predicate = [NSPredicate predicateWithFormat:@\"SELF BETWEEN &#123;2,5&#125;\"]; NSArray fliterArray = [array filteredArrayUsingPredicate:predicate]; [fliterArray enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL _Nonnull stop) &#123; NSLog(@\"fliterArray = %@\",obj); &#125;];&#125; pragma mark 测试Predicate的比较功能 12345678910111213- (void)testPredicateComparation&#123; / (1)比较运算符&gt;,&lt;,==,&gt;=,&lt;=,!= 可用于数值及字符串 例：@\"number &gt; 100\" / NSArray array = [NSArray arrayWithObjects:@1,@2,@3,@4,@5,@2,@6, nil]; NSPredicate predicate = [NSPredicate predicateWithFormat:@\"SELF &gt;4\"]; NSArray fliterArray = [array filteredArrayUsingPredicate:predicate]; [fliterArray enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL _Nonnull stop) &#123; NSLog(@\"fliterArray = %@\",obj); &#125;];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"Xcode代码块的创建","date":"2017-05-19T00:49:07.000Z","path":"2017/05/19/Xcode代码块的创建/","text":"Xcode代码块的创建 我们平常写代码时会遇到提示代码的功能，会出现相应的代码块，这样方便了我们的，提高效率，使我们更便利例如：首先写好你以后决定重用的代码 12345678UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];btn.backgroundColor = [UIColor whiteColor];btn.frame = CGRectMake(10, 100, [UIScreen mainScreen].bounds.size.width - 20, 50);[btn setTitle:@\"点击\" forState:UIControlStateNormal];btn.titleLabel.font = [UIFont systemFontOfSize:14.0f];[btn setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];[btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside];[self.view addSubview:btn]; 之后选中你的代码，向右下角的｛｝拖入，拖入。修改title 我选中的这个地方是你以后用的时候会联想的 取名字简单易记一点最好之后点击一下done就可以了。 注意：completion Scopes选All代码块里面需要提示参数的时候 ， 用&lt;# 你想提示的参数 #&gt;，比如&lt;#CGFloat y#&gt;, 这样就可以在你用的时候有提示了。使用的时候直接敲你之前在Completion Shortcut命名的名字就可以。我的命名是createButton.选中之后回车。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS 用XIB约束后，用代码修改约束","date":"2017-04-28T02:55:52.000Z","path":"2017/04/28/iOS-用XIB约束后，用代码修改约束/","text":"iOS 用XIB约束后，用代码修改约束 当使用xib,并使用了AutoLayout之后,当需要适配机型时,或者手动更改视图的frame的时候,就需要修改约束啦.其实很简单的. 首先从xib中吧改变的约束拖到view上或者ViewController上@property (weak, nonatomic) IBOutlet NSLayoutConstraint *topLayout;机型封装到单例中 全局都可以使用 123456789101112131415+ (UIScreenSizeType)currentScreenSizeType&#123; if (CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size)) &#123; return UIScreenSizeType_640x960; &#125; else if(CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size))&#123; return UIScreenSizeType_640x1136; &#125;else if(CGSizeEqualToSize(CGSizeMake(750, 1334), [[UIScreen mainScreen] currentMode].size))&#123; return UIScreenSizeType_750x1334; &#125;else if(CGSizeEqualToSize(CGSizeMake(1242, 2208), [[UIScreen mainScreen] currentMode].size))&#123; return UIScreenSizeType_1242x2208; &#125; return UIScreenSizeType_000x000;&#125; 123456789if([UIScreen currentScreenSizeType] == UIScreenSizeType_640x960)&#123; _topLayout.constant = 40;&#125;else if([UIScreen currentScreenSizeType] == UIScreenSizeType_640x1136)&#123; _topLayout.constant = 40;&#125;else if([UIScreen currentScreenSizeType] == UIScreenSizeType_750x1334)&#123; _topLayout.constant = 40;&#125;else if([UIScreen currentScreenSizeType] == UIScreenSizeType_1242x2208)&#123; _topLayout.constant = 40;&#125; 2 .还可以为控件自定义一个约束 123456789 NSLayoutConstraint *myConstraint =[NSLayoutConstraint constraintWithItem:iSinaButton //子试图 attribute:NSLayoutAttributeCenterX //子试图的约束属性 relatedBy:NSLayoutRelationEqual //属性间的关系 toItem:self.view//相对于父试图 attribute:NSLayoutAttributeCenterX//父试图的约束属性 multiplier:1.0 constant:0.0];// 固定距离[self.view addConstraint: myConstraint];//为iSinaButton重新添加一个约束","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"Xcode打印数据不完整,只打印了一半","date":"2017-04-28T02:53:07.000Z","path":"2017/04/28/Xcode打印数据不完整-只打印了一半/","text":"Xcode打印数据不完整,只打印了一半 创建一个宏 把这段代码粘上去 在使用的地方调用就可以了12345#ifdef DEBUG#define NSLog(FORMAT, ...) fprintf(stderr, \"%s:%zd\\t%s\\n\", [[[NSString stringWithUTF8String: __FILE__] lastPathComponent] UTF8String], __LINE__, [[NSString stringWithFormat: FORMAT, ## __VA_ARGS__] UTF8String]);#else#define NSLog(FORMAT, ...) nil#endif","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"UIimageView不常用属性","date":"2017-02-22T02:55:21.000Z","path":"2017/02/22/UIimageView不常用属性/","text":"UIimageView不常用属性 UIimageView的transform属性 可以实现调整该view在其superView中的大小和位置，以及进行缩放，平移，旋转以及这两者的任意组着操作 123view.transform=CGAffineTransformScale(view.transform, 0.5, 0.5); // 实现的是放大和缩小 view.transform=CGAffineTransformRotate(view.transform, 0.2); //实现的是旋转view.transform=CGAffineTransformTranslate(view.transform, 20, 20); //实现的是平移 其实就是通过view的矩阵变化实现，当设备监测到旋转的时候，会通知当前程序，当前程序再通知程序中的window，window会通知它的rootViewController的，rootViewController对其view的transform进行设置，最终完成旋转。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS WKWebView的使用","date":"2017-02-20T06:17:59.000Z","path":"2017/02/20/iOS-WKWebView的使用/","text":"iOS WKWebView的使用 WKWebView的简介这个是IOS8之后新增的一个类,也是苹果推崇的一个新的类,使用WKWebView，速度会更快，占用内存少,支持了更多的HTML5特性； 基本使用方法其实和UIWebView的用法没什么区别但是WKWebView相对于UIWebView强大了很多，内存的消耗相对少了，所提供的接口也丰富了。推荐使用多了一部操作就是需要包含webkit框架@import webkit 12345WKWebView *webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];self.view = webView;NSURL *url = [NSURL URLWithString:@\"https://www.baidu.com\"];NSURLRequest *request = [NSURLRequest requestWithURL:url];[webView loadRequest:request]; 代理方法有一些方法和UIWebView是基本一直的,但是因为返回了navigation,所能用到的属性多了很多,另外多了一些方法,将请求与相应的整个过程 1234567891011121314151617181920212223242526272829303132333435- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView&#123;NSLog(@\"webViewWebContentProcessDidTerminate: 当Web视图的网页内容被终止时调用。\");&#125;- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation&#123;[UIApplication sharedApplication].networkActivityIndicatorVisible = NO;NSLog(@\"webView:didFinishNavigation: 响应渲染完成后调用该方法 webView : %@ -- navigation : %@ \\n\\n\",webView,navigation);&#125;- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation&#123;[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;NSLog(@\"webView:didStartProvisionalNavigation: 开始请求 \\n\\n\");&#125;- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation &#123;NSLog(@\"webView:didCommitNavigation: 响应的内容到达主页面的时候响应,刚准备开始渲染页面应用 \\n\\n\");&#125;// error- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error &#123;// 类似 UIWebView 的- webView:didFailLoadWithError:NSLog(@\"webView:didFailProvisionalNavigation:withError: 启动时加载数据发生错误就会调用这个方法。 \\n\\n\");&#125;- (void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error&#123;NSLog(@\"webView:didFailNavigation: 当一个正在提交的页面在跳转过程中出现错误时调用这个方法。 \\n\\n\");&#125;- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;NSLog(@\"请求前会先进入这个方法 webView:decidePolicyForNavigationActiondecisionHandler: %@ \\n\\n \",navigationAction.request);decisionHandler(WKNavigationActionPolicyAllow);&#125;- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler&#123;NSLog(@\"返回响应前先会调用这个方法 并且已经能接收到响应webView:decidePolicyForNavigationResponse:decisionHandler: Response?%@ \\n\\n\",navigationResponse.response);decisionHandler(WKNavigationResponsePolicyAllow);&#125;- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation&#123;NSLog(@\"webView:didReceiveServerRedirectForProvisionalNavigation: 重定向的时候就会调用 \\n\\n\");&#125; 基本使用怎样处理403,404的情况123456789101112131415161718192021222324252627@property (nonatomic, assign) BOOL isPost; // 定义一个变量// 每一个请求开始发送前都会调用这个方法// 1, 定义一个全局变量currentRequest,用作保存当前的请求// 2, 将请求转换成data,然后处理data再将data作为请求数据再次请求- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; if (!_isPost) &#123; NSHTTPURLResponse *response = nil; NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:nil]; if (response.statusCode == 404) &#123; // 这里处理 404 代码 &#125; else if (response.statusCode == 403) &#123; // 这里处理 403 代码 &#125; else &#123; _isPost = true; [webView loadData:data MIMEType:@\"text/html\" textEncodingName:@\"NSUTF8StringEncoding\" baseURL:[request URL]]; &#125; return NO; &#125;else&#123; NSLog(@\"\\n\\n shouldStartLoadWithRequest请求准备 -- %@ \\n\\n \",request); _isPost = NO; return YES; &#125;&#125; 目前，大多数App需要支持iOS7以上的版本，而WKWebView只在iOS8后才能用，所以需要一个兼容性方案，既iOS7下用UIWebView，iOS8后用WKWebView。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"Git本地创建分之并提交到远程","date":"2017-02-16T09:28:44.000Z","path":"2017/02/16/Git本地创建分之并提交到远程/","text":"Git本地创建分之并提交到远程 从命令行创建一个新的仓库123456touch README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin http://svn.vlinker.com.cn:3000/gezhenrong/WYBaseFramework.gitgit push -u origin master 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin 要查看远程库的信息，用git remote 12$ git remoteorigin 或者，用git remote -v显示更详细的信息 123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：1git push origin master 如果要推送其他分支，比如dev，就改成：1git push origin dev master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 SSH Key添加 Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置（github的SSH配置如下：） 设置Git的user name和email： 12$ git config --global user.name \"xuhaiyan\"$ git config --global user.email \"haiyan.xu.vip@gmail.com\" 二、生成SSH密钥过程： 1.查看是否已经有了ssh密钥：cd ~/.ssh如果没有密钥则不会有此文件夹，有则备份删除 2.生存密钥：$ ssh-keygen -t rsa -C “haiyan.xu.vip@gmail.com”按3个回车，密码为空。 最后得到了两个文件：id_rsa和id_rsa.pub 三.添加密钥到ssh：ssh-add 文件名需要之前输入密码。 四.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into 'learngit'...remote: Counting objects: 46, done.remote: Compressing objects: 100% (26/26), done.remote: Total 46 (delta 16), reused 45 (delta 15)Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.Resolving deltas: 100% (16/16), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 提交代码的步揍 git add . git commit -m “###” git remote add origin [url] git push origin 本地分支:远程分支 如果出现 fatal: remote origin already exists输入命令 git remote rm origin 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：1$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 1234567891011$ git commit -m \"add /usr/bin/env\"[dev 291bea8] add /usr/bin/env 1 file changed, 1 insertion(+)$ git push origin devCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 349 bytes, done.Total 3 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git fc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： git提交代码时出现 123456789101112131415error: Unknown subcommand: originusage: git remote [-v | --verbose]or: git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--tags | --no-tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;or: git remote rename &lt;old&gt; &lt;new&gt;or: git remote remove &lt;name&gt;or: git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)or: git remote [-v | --verbose] show [-n] &lt;name&gt;or: git remote prune [-n | --dry-run] &lt;name&gt;or: git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)...]or: git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;...or: git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]or: git remote set-url --add &lt;name&gt; &lt;newurl&gt;or: git remote set-url --delete &lt;name&gt; &lt;url&gt;-v, --verbose be verbose; must be placed before a subcommand 解决的方法： 1.修改命令 git remote set-url origin [url] 2.先删后加 git remote rm origingit remote add origin [url] 从命令行推送已经创建的仓库12git remote add origin http://svn.vlinker.com.cn:3000/gezhenrong/WYBaseFramework.gitgit push -u origin master","tags":[{"name":"Git","slug":"Git","permalink":"http://gezhenrong.cn/tags/Git/"}]},{"title":"iOS设置父视图透明度而不影响子视图","date":"2017-02-16T07:03:35.000Z","path":"2017/02/16/iOS设置父视图透明度而不影响子视图/","text":"iOS设置父视图透明度而不影响子视图 第一种方案：今天接到项目需求，要求界面是透明的UIView上的视图是透明的，但不影响子视图上的视图。 123UIView *blackV = [[UIView alloc]initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HIGHT)]; blackV.backgroundColor = [UIColor colorWithRed:122/255.0 green:123/255.0 blue:234/255.0 alpha:0.7]; [self.view addSubView: blackV] 第二种方案：在iOS8后，苹果开放了不少创建特效的接口，其中包括创建毛玻璃的接口。 12345678910111213UIBlurEffect *blur = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];UIVisualEffectView *effectview = [[UIVisualEffectView alloc] initWithEffect:blur];effectview.frame = CGRectMake(0, 0, DEF_SCREEN_WIDTH, DEF_SCREEN_WIDTH + 30);effectview.contentView.backgroundColor = [UIColor greenColor];&lt;!--effectview.contentView.alpha = 0.0;--&gt;if (iOS8) &#123; [self.view addSubview:self.effectview]; self.backgroundColor = RGB_COLOR(80, 80, 80); self.backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@\"princess\"]];&#125;else&#123; self.backgroundColor = RGBA_COLOR(20, 20, 20, .7); self.backgroundColor = [UIColor whiteColor];&#125; 这段代码是在当前视图控制器上添加了一个UIImageView作为背景图另外，尽量避免将UIVisualEffectView对象的alpha值设置为小于1.0的值，因为创建半透明的视图会导致系统在离屏渲染时去对UIVisualEffectView对象及所有的相关的子视图做混合操作。这不但消耗CPU/GPU，也可能会导致许多效果显示不正确或者根本不显示。 第三种方案：UIViewController 推出另外一个半透明的UIViewController这里通过UIView 也是可以实现的，只是代码已经写好，就尝试了下推出半透明UIViewController的情况视图1（ViewController1）中添加以下代码 1234ViewController2 *lagerPicVC = [[ViewController2 alloc]init];self.modalPresentationStyle = UIModalPresentationCurrentContext;//关键语句，必须有[self presentViewController:lagerPicVC animated:YES completion:nil];[self.view setBackgroundColor:[UIColor colorWithRed:0 green:0 blue:0 alpha:0.868f]]; 视图2（ViewController2）中设置背景透明度","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS常用验证","date":"2017-01-08T15:33:25.000Z","path":"2017/01/08/iOS常用验证/","text":"iOS常用 手机 身份证 验证 验证邮箱12345678+ (BOOL)isValidUsername:(NSString *)username &#123; // 验证用户名 - 邮箱 NSString *emailRegex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]&#123;2,4&#125;\"; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", emailRegex]; return [emailTest evaluateWithObject:username];&#125; 验证手机号12345678910111213141516171819202122232425262728293031323334353637383940+ (BOOL)isTelephone:(NSString *)mobile&#123; if (mobile.length &lt; 11) &#123; return NO; &#125;else&#123; /** * 移动号段正则表达式 */ NSString *CM_NUM = @\"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d&#123;8&#125;|(1705)\\\\d&#123;7&#125;$\"; /** * 联通号段正则表达式 */ NSString *CU_NUM = @\"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d&#123;8&#125;|(1709)\\\\d&#123;7&#125;$\"; /** * 电信号段正则表达式 */ NSString *CT_NUM = @\"^((133)|(153)|(177)|(18[0,1,9]))\\\\d&#123;8&#125;$\"; NSPredicate *pred1 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CM_NUM]; BOOL isMatch1 = [pred1 evaluateWithObject:mobile]; NSPredicate *pred2 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CU_NUM]; BOOL isMatch2 = [pred2 evaluateWithObject:mobile]; NSPredicate *pred3 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CT_NUM]; BOOL isMatch3 = [pred3 evaluateWithObject:mobile]; if (isMatch1 || isMatch2 || isMatch3) &#123; return YES;// if (isMatch1) &#123;// return @\"该号码是一个正确的移动手机号码\";// &#125;else if (isMatch2) &#123;// return @\"该号码是一个正确的联通手机号码\";// &#125;else &#123;// return @\"该号码是一个正确的电信手机号码\";// &#125; &#125;else&#123; return NO; &#125; &#125; return nil;&#125; 验证身份证是否合法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172+ (BOOL)validateIDCardNumber:(NSString *)valueStr&#123; valueStr = [valueStr stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; NSUInteger length =0; if (!valueStr) &#123; return NO; &#125;else &#123; length = valueStr.length; if (length !=15 &amp;&amp; length !=18) &#123; return NO; &#125; &#125; // 省份代码 NSArray *areasArray =@[@\"11\",@\"12\", @\"13\",@\"14\", @\"15\",@\"21\", @\"22\",@\"23\", @\"31\",@\"32\", @\"33\",@\"34\", @\"35\",@\"36\", @\"37\",@\"41\",@\"42\",@\"43\", @\"44\",@\"45\", @\"46\",@\"50\", @\"51\",@\"52\", @\"53\",@\"54\", @\"61\",@\"62\", @\"63\",@\"64\", @\"65\",@\"71\", @\"81\",@\"82\", @\"91\"]; NSString *valueStart2 = [valueStr substringToIndex:2]; BOOL areaFlag =NO; for (NSString *areaCode in areasArray) &#123; if ([areaCode isEqualToString:valueStart2]) &#123; areaFlag =YES; break; &#125; &#125; if (!areaFlag) &#123; return false; &#125; NSRegularExpression *regularExpression; NSUInteger numberofMatch; int year =0; switch (length) &#123; case15: year = [valueStr substringWithRange:NSMakeRange(6,2)].intValue +1900; if (year %4 ==0 || (year %100 ==0 &amp;&amp; year %4 ==0)) &#123; regularExpression = [[NSRegularExpression alloc]initWithPattern:@\"^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;$\" options:NSRegularExpressionCaseInsensitive error:nil];//测试出生日期的合法性 &#125;else &#123; regularExpression = [[NSRegularExpression alloc]initWithPattern:@\"^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;$\" options:NSRegularExpressionCaseInsensitive error:nil];//测试出生日期的合法性 &#125; numberofMatch = [regularExpression numberOfMatchesInString:valueStr options:NSMatchingReportProgress range:NSMakeRange(0, valueStr.length)]; if(numberofMatch &gt;0) &#123; return YES; &#125;else &#123; return NO; &#125; case18: year = [valueStr substringWithRange:NSMakeRange(6,4)].intValue; if (year %4 ==0 || (year %100 ==0 &amp;&amp; year %4 ==0)) &#123; regularExpression = [[NSRegularExpression alloc]initWithPattern:@\"^[1-9][0-9]&#123;5&#125;19[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$\"options:NSRegularExpressionCaseInsensitive error:nil];//测试出生日期的合法性 &#125;else &#123; regularExpression = [[NSRegularExpression alloc]initWithPattern:@\"^[1-9][0-9]&#123;5&#125;19[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;[0-9Xx]$\"options:NSRegularExpressionCaseInsensitive error:nil];//测试出生日期的合法性 &#125; numberofMatch = [regularExpression numberOfMatchesInString:valueStroptions:NSMatchingReportProgress range:NSMakeRange(0, valueStr.length)]; if(numberofMatch &gt;0) &#123; int S = ([valueStr substringWithRange:NSMakeRange(0,1)].intValue + [valueStr substringWithRange:NSMakeRange(10,1)].intValue) *7 + ([valueStr substringWithRange:NSMakeRange(1,1)].intValue + [valueStr substringWithRange:NSMakeRange(11,1)].intValue) *9 + ([valueStr substringWithRange:NSMakeRange(2,1)].intValue + [valueStr substringWithRange:NSMakeRange(12,1)].intValue) *10 + ([valueStr substringWithRange:NSMakeRange(3,1)].intValue + [valueStr substringWithRange:NSMakeRange(13,1)].intValue) *5 + ([valueStr substringWithRange:NSMakeRange(4,1)].intValue + [valueStr substringWithRange:NSMakeRange(14,1)].intValue) *8 + ([valueStr substringWithRange:NSMakeRange(5,1)].intValue + [valueStr substringWithRange:NSMakeRange(15,1)].intValue) *4 + ([valueStr substringWithRange:NSMakeRange(6,1)].intValue + [valueStr substringWithRange:NSMakeRange(16,1)].intValue) *2 + [valueStr substringWithRange:NSMakeRange(7,1)].intValue *1 + [valueStr substringWithRange:NSMakeRange(8,1)].intValue *6 + [valueStr substringWithRange:NSMakeRange(9,1)].intValue *3; int Y = S %11; NSString *M =@\"F\"; NSString *JYM =@\"10X98765432\"; M = [JYM substringWithRange:NSMakeRange(Y,1)];// 判断校验位 if ([M isEqualToString:[valueStr substringWithRange:NSMakeRange(17,1)]]) &#123; return YES;// 检测ID的校验位 &#125;else &#123; return NO; &#125; &#125;else &#123; return NO; &#125; default: return false; &#125; &#125; 获取星期12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667+(NSString *)dateTomorrow:(NSDate *)date&#123; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; NSInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSWeekdayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *comps = [calendar components:unitFlags fromDate:date]; long month = [comps month]; long day = [comps day]; long hour = [comps hour]; long minute = [comps minute]; long weekday = [comps weekday]; NSString *weekdayString = @\"\"; switch (weekday) &#123; case 1: weekdayString = @\"周日\"; break; case 2: weekdayString = @\"周一\"; break; case 3: weekdayString = @\"周二\"; break; case 4: weekdayString = @\"周三\"; break; case 5: weekdayString = @\"周四\"; break; case 6: weekdayString = @\"周五\"; break; case 7: weekdayString = @\"周六\"; break; default: break; &#125; NSString *dayStr = nil; if (day &lt; 10) &#123; dayStr = [NSString stringWithFormat:@\"0%ld\",day]; &#125;else&#123; dayStr = [NSString stringWithFormat:@\"%ld\",day]; &#125; NSString *hourStr = nil; if (hour &lt; 10) &#123; hourStr = [NSString stringWithFormat:@\"0%ld\",hour]; &#125;else&#123; hourStr = [NSString stringWithFormat:@\"%ld\",hour]; &#125; NSString *minuteStr = nil; if (minute &lt; 10) &#123; minuteStr = [NSString stringWithFormat:@\"0%ld\",minute]; &#125;else&#123; minuteStr = [NSString stringWithFormat:@\"%ld\",minute]; &#125; return [NSString stringWithFormat:@\"%ld/%@ %@:%@\",month,dayStr,hourStr,minuteStr]; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"Xcode编译常见错误解决","date":"2017-01-08T15:01:13.000Z","path":"2017/01/08/Xcode编译常见错误解决/","text":"Xcode编译常见错误解决 linker command failed with exit code 1 (use -v to see invocation)出现以上错误，现总结如下解决方法: 1Showing All Issues clang: error: linker command failed with exit code 1 (use -v to see invocation) 检查引用文件是否出错，把 x.h文件弄成了x.m文件,检查一下你的所有引用； 在工作左边导航栏Target–&gt;Build Phases–&gt;compile Sources中，第三库库的所有.m文件时候重复添加. 设置 Project -&gt; Pods 下所有第三方库的 Build Active Architecture Only 为 NO; PonyDebugger是一个很给力的iOS调试工具,它的监视器安装在Chrome浏览器下做为插件使用,通过监视器和PonyDebugger的iOS SDK相辅相成,可以很好的监视App的运作情况.它的突出的亮点功能如下: 实时的检测应用与网络的交互情况 查看应用内Core Data的数据变化 实时反馈UI层的层级情况 数据类型不对 是NSNuber类型1[TitleModel length]: unrecognized selector sent to instance 0x7f9c9ace6940’l cell里面没有对应相应的key 1-[SpaceModel objectForKey:]: unrecognized selector sent to instance 0x7fda23 1UITableView was deallocated while key value observers were still registered with it 翻译的意思大概就是，uitableview注册了观察者，然后没有被注销掉，又开始重复使用了，我是这么理解的。我这个页面的功能很简单。就是从列表页面进入到详情页，然后详情页的布局是一个scrollview上放了一个uitableview,uitableview继承了上拉刷新。 我发现这个问题的由来： 当我第一次点详情页后，然后返回，第二次进去，然后返回，次数多了以后。然后就 Collapse崩溃了。解决方法： 12345- ( void )dealloc&#123; [ _header free ]; [ _footer free ];&#125; EXC_BAD_ACCESS错误。这意味着应用程序有一个内存管理问题。 XCode 7上传遇到ERROR ITMS-90535 Unexpected CFBundleExecutable Key. 的解决办法在工程里面搜索info.plist,可以先搜索info，找到第三方的info.plist文件，删除里面的Executable file对应的一整行，包括值。 duplicate symbols for architecture armv7解决办法XCODE编译的时候报错：duplicate symbols for architecture armv7 首先排查是否有名字重复的文件； 检查是否在#import头文件的时候，不小心把.h写成了.m。 1'/Users/one/Desktop/didiyuechang907/WYBaseFramework/Class/ThirdLib/UMSocial_Sdk_Extra_Frameworks/TencentOpenAPI/libSocialQQ.a(UMSocialQQHandler.o)' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64 Xcode 发布新版本 ITMS-90034错误","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"算法问题","date":"2016-12-14T04:59:47.000Z","path":"2016/12/14/算法问题/","text":"算法问题 ###Base64Base64编码的思想是是采用64个基本的ASCII码字符对数据进行重新编码,举例： 1. 将对ABC进行BASE64编码首先取ABC对应的ASCII码值。A（65）B（66）C（67）。 2. 再取二进制值A（01000001）B（01000010）C（01000011）， 3. 然后把这三个字节的二进制码接起来（010000010100001001000011）， 4. 再以6位为单位分成4个数据块并在最高位填充两个0后形成4个字节的编码后的值（00010000）（00010100）（00001001）（00000011）。蓝色部分为真实数据。再把这四个字节数据转化成10进制数得（16）（20）（19）（3）。 5. 最后根据BASE64给出的64个基本字符表，查出对应的ASCII码字符（Q）（U）（J）（D）。这里的值实际就是数据在字符表中的索引。 注：BASE64字符表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ 解码过程就是把4个字节再还原成3个字节再根据不同的数据形式把字节数组重新整理成数据。 基本原理： 原本是 8个bit 一组表示数据,改为 6个bit一组表示数据,不足的部分补零,每 两个0 用 一个 = 表示 用base64 编码之后,数据长度会变大,增加了大约 1/3 左右.(8-6)/6可进行反向解密 ###DES DES是一个分组加密算法，他以64位为分组对数据加密。同时DES也是一个对称算法：加密和解密用的是同一个算法。它的密匙长度是56位（因为每个第8位都用作奇偶校验）,密匙可以是任意的56位的数，而且可以任意时候改变。其中有极少量的数被认为是弱密匙，但是很容易避开他们。所以保密性依赖于密钥。解密过程：在经过所有的代替、置换、异或盒循环之后，你也许认为解密算法与加密算法完全不同。恰恰相反，经过精心选择的各种操作，获得了一个非常有用的性质：加密和解密使用相同的算法。DES加密和解密唯一的不同是密匙的次序相反。如果各轮加密密匙分别是K1,K2,K3….K16那么解密密匙就是K16,K15,K14…K1。 ###MD5MD5就是把一个任意长度的字节串变换成一定长的大整数，请注意我使用了”字节串”而不是”字符串”这个词，是因为这种变换只与字节的值有关，与字符集或编码方式无关。MD5将任意长度的”字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。 token值登录令牌.利用 token 值来判断用户的登录状态.类似于 MD5 加密之后的长字符串.用户登录成功之后,在后端(服务器端)会根据用户信息生成一个唯一的值.这个值就是 token 值. 基本使用: 在服务器端(数据库)会保存这个 token 值,以后利用这个 token 值来检索对应的用户信息,并且判断用户的登录状态. 用户登录成功之后,服务器会将生成的 token 值返回给 客户端,在客户端也会保存这个 token 值.(一般可以保存在 cookie 中,也可以自己手动确定保存位置(比如偏好设置.)). 以后客户端在发送新的网络请求的时候,会默认自动附带这个 token 值(作为一个参数传递给服务器.).服务器拿到客户端传递的 token 值跟保存在 数据库中的 token 值做对比,以此来判断用户身份和登录状态. 判断登录状态: 如果客户端没有这个 token 值,意味着没有登录成功过,提示用户登录. 如果客户端有 token 值,一般会认为登录成功.不需要用户再次登录(输入账号和密码信息).","tags":[{"name":"算法","slug":"算法","permalink":"http://gezhenrong.cn/tags/算法/"}]},{"title":"iOS运用Runtime全局修改UILabel的默认字体","date":"2016-12-10T06:22:40.000Z","path":"2016/12/10/iOS运用Runtime全局修改UILabel的默认字体/","text":"iOS运用Runtime全局修改UILabel的默认字体 在项目中需要改变所有UILabel的默认字体 处理方式 使用框架创建我们自己的BaseLabel类，在其中进行默认字体的设置，并且并不影响在使用过程中特殊设置字体的label，这种方式可以满足我们的需求，但是并不适于我们的场景，项目已经成熟，重建一个label基类，来让所有的UILabel都换成它的工作量不会比重新设置所有label字体的工作量小太多。但这也是有优势的，至少如果下次再换字体，我们就不用麻烦了。 使用runtime替换UILabel初始化方法这是最简单方便的方法，我们可以使用runtime机制替换掉UILabel的初始化方法，在其中对label的字体进行默认设置。因为Label可以从initWithFrame、init和nib文件三个来源初始化，所以我们需要将这三个初始化的方法都替换掉。 在其中加入如下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182831#import \"UILabel+YHBaseChangeDefaultFont.h\"2#import &lt;objc/runtime.h&gt;@implementation UILabel (YHBaseChangeDefaultFont) *每个NSObject的子类都会调用下面这个方法 在这里将init方法进行替换，使用我们的新字体 *如果在程序中又特殊设置了字体 则特殊设置的字体不会受影响 但是不要在Label的init方法中设置字体 *从init和initWithFrame和nib文件的加载方法 都支持更换默认字体 */+(void)load&#123; //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); //替换三个方法 SEL originalSelector = @selector(init); SEL originalSelector2 = @selector(initWithFrame:); SEL originalSelector3 = @selector(awakeFromNib); SEL swizzledSelector = @selector(YHBaseInit); SEL swizzledSelector2 = @selector(YHBaseInitWithFrame:); SEL swizzledSelector3 = @selector(YHBaseAwakeFromNib); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method originalMethod2 = class_getInstanceMethod(class, originalSelector2); Method originalMethod3 = class_getInstanceMethod(class, originalSelector3); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); Method swizzledMethod2 = class_getInstanceMethod(class, swizzledSelector2); Method swizzledMethod3 = class_getInstanceMethod(class, swizzledSelector3); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); BOOL didAddMethod2 = class_addMethod(class, originalSelector2, method_getImplementation(swizzledMethod2), method_getTypeEncoding(swizzledMethod2)); BOOL didAddMethod3 = class_addMethod(class, originalSelector3, method_getImplementation(swizzledMethod3), method_getTypeEncoding(swizzledMethod3)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else&#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; if (didAddMethod2) &#123; class_replaceMethod(class, swizzledSelector2,method_getImplementation(originalMethod2),method_getTypeEncoding(originalMethod2)); &#125;else &#123; method_exchangeImplementations(originalMethod2, swizzledMethod2); &#125; if (didAddMethod3) &#123; class_replaceMethod(class, swizzledSelector3, method_getImplementation(originalMethod3), method_getTypeEncoding(originalMethod3)); &#125;else &#123;method_exchangeImplementations(originalMethod3, swizzledMethod3); &#125; &#125;); &#125;在这些方法中将你的字体名字换进去- (instancetype)YHBaseInit&#123; id __self = [self YHBaseInit]; UIFont * font = [UIFont fontWithName:@\"这里输入你的字体名字\" size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; return __self;&#125;-(instancetype)YHBaseInitWithFrame:(CGRect)rect&#123; id __self = [self YHBaseInitWithFrame:rect]; UIFont * font = [UIFont fontWithName:@\"这里输入你的字体名字\" size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; return __self;&#125;-(void)YHBaseAwakeFromNib&#123; [self YHBaseAwakeFromNib]; UIFont * font = [UIFont fontWithName:@\"这里输入你的字体名字\" size:self.font.pointSize]; if (font) &#123; self.font=font; &#125;&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS线上修复bug","date":"2016-12-09T12:25:24.000Z","path":"2016/12/09/iOS线上修复bug/","text":"iOS 经验总结 以前对于iOS来说，线上出现bug，都很苦恼，因为iOS上线审核周期太长，至少需要一周时间，还是在审核成功的情况下。很多公司都没有专业的测试员，都是程序员做测试，给程序员很大压力。如果出现bug，不能及时修复，所以很苦恼。我无意在查资料时，看到一篇文章，利用JSPatchPlatform框架可以线上修复bug，当时好激动啊。我们的福利啊。下面是JSPatchPlatform框架的介绍 作用:是iOSApp获取脚本语言能力：动态更新App，替换项目原生代码修复bug。 当时听到JSPatch有这个动态修复bug的功能，感觉有点不可思议，同时觉得这个JSPatch简直太厉害了。用了它就可以及时修改App出现的bug，节约了上线先版本修复bug的时间。 根本原理：利用OC的动态语言特性去动态修改类的方法实现,利用了OC的消息转发机制. 使用:JSPatch Platform就是一个第三方的JSPatch平台,帮助客户端开发者下发和管理脚本，处理传输安全等部署工作。 有了JSPatch平台就不用我们自己的后台去操作了，当然如果我们自己的后台愿意做能做也可以交给我们自己的后台去做。 首先需要登录官网注册（http://jspatch.com,成为它的一个用户 添加自己要使用JSPatch的App,添加App完成后会相应地有一个AppKey作为App的唯一标识 App添加完成后我们还需要为App添加App版本，这样这个平台才能知道我们的哪个版 需要修复的代码的时候需要写一个js脚本本的App需要使用JSPatch进行代码动态修复 在 AppDelegate.m 里载入文件，并调用 +startWithAppKey: 方法，参数为第一步获得的 AppKey。接着调用 +sync 方法检查更新 123456@implementation AppDelegate1- (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [JSPatch startWithAppKey:@&quot;你的AppKey&quot;]; [JSPatch sync];&#125;@end 假设已接入 JSPatch SDK 的某线上 APP 发现一处代码有 bug 导致 crash 12345678@implementation XRTableViewController. - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSString *content = self.dataSource[[indexPath row]]; //可能会超出数组范围导致crash XRViewController *controller = [[JPViewController alloc] initWithContent:content]; [self.navigationController pushViewController:controller];&#125;@end 对此我们写了如下 JS 脚本准备替换上述方法修复这个 bug 1234567891011//main.jsdefineClass(\"XRTableViewController\", &#123; tableView_didSelectRowAtIndexPath: function(tableView, indexPath) &#123; var row = indexPath.row() if (self.dataSource().length &gt; row) &#123; //加上判断越界的逻辑 var content = self.dataArr()[row]; var controller = XRViewController.alloc().initWithContent(content); self.navigationController().pushViewController(controller); &#125; &#125;&#125;) 如果我们不会写JS的话，平台还为我们提供脚本编辑器http://www.jspatch.com/Tools/convertor可以进行编辑 这时我们需要在Xcode中创建一个main.js文件，创建一个空文件即可,JS脚本的文件名必须是**main.js**. ![Alt text](http://img.blog.csdn.net/20160922180305636?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 注意 若使用 XCode8 接入，需要在项目 Capabilities 打开 Keychain Sharing 开关，否则在模拟器下载脚本后会出现 decompress error, md5 didn’t match 错误（真机无论是否打开都没问题） 修改/删除JS脚本 若后续需要对这个脚本进行修改，可以重新上传新的脚本，APP 客户端会在请求时发现脚本已更新，下载最新脚本覆盖原来的，下次启动时执行。 若想直接取消某个 APP 版本的 JS 脚本补丁，可以直接在 APP 版本界面删除此 APP 版本，APP 客户端会在请求时发现脚本已被删除，即刻删除本地 JS 脚本文件，下次启动时不再加载。 这门技术的确挺叼的，腾讯、阿里都在用，我已经用到项目中了，感觉确实挺神奇。不错，我喜欢。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"获取iOS设备信息","date":"2016-12-03T07:55:57.000Z","path":"2016/12/03/获取iOS设备信息/","text":"获取iOS设备信息 获取设备上的一些信息 获取电池电量(一般用百分数表示,大家自行处理就好) 1234-(CGFloat)getBatteryQuantity&#123; return [[UIDevice currentDevice] batteryLevel];&#125; 获取电池状态(UIDeviceBatteryState为枚举类型) 1234-(UIDeviceBatteryState)getBatteryStauts&#123; return [UIDevice currentDevice].batteryState;&#125; 获取总内存大小 1234-(long long)getTotalMemorySize&#123; return [NSProcessInfo processInfo].physicalMemory;&#125; 获取当前可用内存 1234567891011-(long long)getAvailableMemorySize&#123; vm_statistics_data_t vmStats; mach_msg_type_number_t infoCount = HOST_VM_INFO_COUNT; kern_return_t kernReturn = host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmStats, &amp;infoCount); if (kernReturn != KERN_SUCCESS) &#123; return NSNotFound; &#125; return ((vm_page_size * vmStats.free_count + vm_page_size * vmStats.inactive_count));&#125; 获取已使用内存 1234567891011121314- (double)getUsedMemory&#123; task_basic_info_data_t taskInfo; mach_msg_type_number_t infoCount = TASK_BASIC_INFO_COUNT; kern_return_t kernReturn = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount); if (kernReturn != KERN_SUCCESS ) &#123; return NSNotFound; &#125; return taskInfo.resident_size;&#125; 获取总磁盘容量 1234567891011include -(long long)getTotalDiskSize&#123; struct statfs buf; unsigned long long freeSpace = -1; if (statfs(\"/var\", &amp;buf) &gt;= 0) &#123; freeSpace = (unsigned long long)(buf.f_bsize * buf.f_blocks); &#125; return freeSpace;&#125; 获取可用磁盘容量 12345678910-(long long)getAvailableDiskSize&#123; struct statfs buf; unsigned long long freeSpace = -1; if (statfs(\"/var\", &amp;buf) &gt;= 0) &#123; freeSpace = (unsigned long long)(buf.f_bsize * buf.f_bavail); &#125; return freeSpace;&#125; 容量转换 12345678910111213141516-(NSString )fileSizeToString:(unsigned long long)fileSize&#123; NSInteger KB = 1024; NSInteger MB = KB*KB; NSInteger GB = MB*KB; if (fileSize &lt; 10) &#123; return @\"0 B\"; &#125;else if (fileSize &lt; KB) &#123; return @\"&lt; 1 KB\"; &#125;else if (fileSize &lt; MB) &#123; return [NSString stringWithFormat:@\"%.1f KB\",((CGFloat)fileSize)/KB]; &#125;else if (fileSize &lt; GB) &#123; return [NSString stringWithFormat:@\"%.1f MB\",((CGFloat)fileSize)/MB]; &#125;else &#123; return [NSString stringWithFormat:@\"%.1f GB\",((CGFloat)fileSize)/GB]; &#125;&#125; 型号import 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455+ (NSString *)getCurrentDeviceModel:(UIViewController *)controller&#123; int mib[2]; size_t len; char *machine; mib[0] = CTL_HW; mib[1] = HW_MACHINE; sysctl(mib, 2, NULL, &amp;len, NULL, 0); machine = malloc(len); sysctl(mib, 2, machine, &amp;len, NULL, 0); NSString *platform = [NSString stringWithCString:machine encoding:NSASCIIStringEncoding]; free(machine); if ([platform isEqualToString:@\"iPhone3,1\"]) return @\"iPhone 4 (A1332)\"; if ([platform isEqualToString:@\"iPhone3,2\"]) return @\"iPhone 4 (A1332)\"; if ([platform isEqualToString:@\"iPhone3,3\"]) return @\"iPhone 4 (A1349)\"; if ([platform isEqualToString:@\"iPhone4,1\"]) return @\"iPhone 4s (A1387/A1431)\"; if ([platform isEqualToString:@\"iPhone5,1\"]) return @\"iPhone 5 (A1428)\"; if ([platform isEqualToString:@\"iPhone5,2\"]) return @\"iPhone 5 (A1429/A1442)\"; if ([platform isEqualToString:@\"iPhone5,3\"]) return @\"iPhone 5c (A1456/A1532)\"; if ([platform isEqualToString:@\"iPhone5,4\"]) return @\"iPhone 5c (A1507/A1516/A1526/A1529)\"; if ([platform isEqualToString:@\"iPhone6,1\"]) return @\"iPhone 5s (A1453/A1533)\"; if ([platform isEqualToString:@\"iPhone6,2\"]) return @\"iPhone 5s (A1457/A1518/A1528/A1530)\"; if ([platform isEqualToString:@\"iPhone7,1\"]) return @\"iPhone 6 Plus (A1522/A1524)\"; if ([platform isEqualToString:@\"iPhone7,2\"]) return @\"iPhone 6 (A1549/A1586)\"; if ([platform isEqualToString:@\"iPhone8,1\"]) return @\"iPhone 6s\"; if ([platform isEqualToString:@\"iPhone8,2\"]) return @\"iPhone 6s Plus\"; if ([platform isEqualToString:@\"iPod1,1\"]) return @\"iPod Touch 1G (A1213)\"; if ([platform isEqualToString:@\"iPod2,1\"]) return @\"iPod Touch 2G (A1288)\"; if ([platform isEqualToString:@\"iPod3,1\"]) return @\"iPod Touch 3G (A1318)\"; if ([platform isEqualToString:@\"iPod4,1\"]) return @\"iPod Touch 4G (A1367)\"; if ([platform isEqualToString:@\"iPod5,1\"]) return @\"iPod Touch 5G (A1421/A1509)\"; if ([platform isEqualToString:@\"iPad1,1\"]) return @\"iPad 1G (A1219/A1337)\"; if ([platform isEqualToString:@\"iPad2,1\"]) return @\"iPad 2 (A1395)\"; if ([platform isEqualToString:@\"iPad2,2\"]) return @\"iPad 2 (A1396)\"; if ([platform isEqualToString:@\"iPad2,3\"]) return @\"iPad 2 (A1397)\"; if ([platform isEqualToString:@\"iPad2,4\"]) return @\"iPad 2 (A1395+New Chip)\"; if ([platform isEqualToString:@\"iPad2,5\"]) return @\"iPad Mini 1G (A1432)\"; if ([platform isEqualToString:@\"iPad2,6\"]) return @\"iPad Mini 1G (A1454)\"; if ([platform isEqualToString:@\"iPad2,7\"]) return @\"iPad Mini 1G (A1455)\"; if ([platform isEqualToString:@\"iPad3,1\"]) return @\"iPad 3 (A1416)\"; if ([platform isEqualToString:@\"iPad3,2\"]) return @\"iPad 3 (A1403)\"; if ([platform isEqualToString:@\"iPad3,3\"]) return @\"iPad 3 (A1430)\"; if ([platform isEqualToString:@\"iPad3,4\"]) return @\"iPad 4 (A1458)\"; if ([platform isEqualToString:@\"iPad3,5\"]) return @\"iPad 4 (A1459)\"; if ([platform isEqualToString:@\"iPad3,6\"]) return @\"iPad 4 (A1460)\"; if ([platform isEqualToString:@\"iPad4,1\"]) return @\"iPad Air (A1474)\"; if ([platform isEqualToString:@\"iPad4,2\"]) return @\"iPad Air (A1475)\"; if ([platform isEqualToString:@\"iPad4,3\"]) return @\"iPad Air (A1476)\"; if ([platform isEqualToString:@\"iPad4,4\"]) return @\"iPad Mini 2G (A1489)\"; if ([platform isEqualToString:@\"iPad4,5\"]) return @\"iPad Mini 2G (A1490)\"; if ([platform isEqualToString:@\"iPad4,6\"]) return @\"iPad Mini 2G (A1491)\"; if ([platform isEqualToString:@\"i386\"]) return @\"iPhone Simulator\"; if ([platform isEqualToString:@\"x86_64\"]) return @\"iPhone Simulator\"; return platform;&#125; 可以根据自己的需求增改。有人说也可以按照手机屏幕来判断，但5和5s/5c等手机屏幕相同尺寸则无法判断。。。我只做了iPhone的机型，所以iPad和iPod Touch的信息并没有更新到最新，也请朋友们补充。 IP地址#import 和#import 12345678910111213141516171819202122- (NSString *)deviceIPAdress &#123; NSString *address = @\"an error occurred when obtaining ip address\"; struct ifaddrs *interfaces = NULL; struct ifaddrs *temp_addr = NULL; int success = 0; success = getifaddrs(&amp;interfaces); if (success == 0) &#123; // 0 表示获取成功 temp_addr = interfaces; while (temp_addr != NULL) &#123; if( temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) &#123; // Check if interface is en0 which is the wifi connection on the iPhone if ([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@\"en0\"]) &#123; // Get NSString from C String address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)]; &#125; &#125; temp_addr = temp_addr-&gt;ifa_next; &#125; &#125; freeifaddrs(interfaces); return address;&#125; 当前手机连接的WIFI名称(SSID)需要#import 12345678910111213141516171819- (NSString *)getWifiName&#123; NSString *wifiName = nil; CFArrayRef wifiInterfaces = CNCopySupportedInterfaces(); if (!wifiInterfaces) &#123; return nil; &#125; NSArray *interfaces = (__bridge NSArray *)wifiInterfaces; for (NSString *interfaceName in interfaces) &#123; CFDictionaryRef dictRef = CNCopyCurrentNetworkInfo((__bridge CFStringRef)(interfaceName)); if (dictRef) &#123; NSDictionary *networkInfo = (__bridge NSDictionary *)dictRef; wifiName = [networkInfo objectForKey:(__bridge NSString *)kCNNetworkInfoKeySSID]; CFRelease(dictRef); &#125; &#125; CFRelease(wifiInterfaces); return wifiName;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"CocoaPods遇到的坑","date":"2016-12-02T06:12:11.000Z","path":"2016/12/02/CocoaPods遇到的坑/","text":"CocoaPods 1.0 + 适配 前段时间写一个demo用到CocoaPods，报错CocoaPods版本要升级于是我开始从头开始走流程一步步走发现很多问题，首先发现淘宝的源停止了更新， CocoaPods的安装CocoaPods可以方便地通过Mac自带的RubyGems安装。 设置ruby的软件源这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源gem sources -l #(查看当前ruby的源)gem sources –remove https://rubygems.org/ #(移除当前ruby的源) 1234$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.org确保只有 gems.ruby-china.org 淘宝镜像源已停止维护，所以要换到 https://gems.ruby-china.org 设置gem为最新版本如果gem太老，可以尝试用如下命令升级gem：在Terminal输入以下命令：sudo gem update –system会出现12ERROR: While executing gem ... (TypeError) no implicit conversion of nil into String 解决方法：这是一个bug 2.5.x ruby gem安装程序的版本，补丁文件installer.rb(on my machine in /usr/local/lib/ruby/2.3.0/rubygems/installer.rb)如下：Replace:12if ruby_executable then question &lt;&lt; existing With:12if ruby_executable then question &lt;&lt; (existing || 'an unknown executable') 再次执行1sudo gem update --system 执行安装CocoaPods命令执行安装CocoaPods命令1sudo gem install cocoapods 如果出现错误请执行1sudo gem install -n /usr/local/bin cocoapods","tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://gezhenrong.cn/tags/CocoaPods/"}]},{"title":"iOS App之间的跳转","date":"2016-10-30T06:43:04.000Z","path":"2016/10/30/iOS-App之间的跳转/","text":"iOS App之间的跳转 在开发之中我们经常遇到需要从我们当前程序跳入到另外一个程序中例如： 使用第三方登录时，需要跳转社交APP，比如常见的QQ、微信、淘宝、支付宝等 分享我们的消息到其他APP，最常见的就是分享到QQ和微信，推广我们的APP 第三方支付，微信和支付宝 导航，跳转到地图类应用 跳转到系统的APP，打电话，发短信，发邮件等 这是从一个APP跳到另一个APP的指定页面 实现原理我们想要打开iOS中的一个应用，只需要拿到这个应用的协议头，我们就可以实现从一个APP跳到另外一个APP 假设我们现在有两个APP，APP-1和APP-2，需要从APP-1跳到APP-2那么我们就需要给APP-2绑定一个URL Schemes(自定义的应用协议头)，在APP-1中我们就可以实现用这个协议头跳到APP-2 一个APP直接跳到另外一个APP实现创建两个项目APP-1和APP-2 在APP-2中，我们来绑定URL Schemes 注意，这两个APP得在手机上都安装上，才能跳转 跳转方法 1234567891011121314- (void)jumpToApp2&#123; //获取APP2的URL Scheme NSURL *appURL = [NSURL URLWithString:@\"APP2://\"]; //判断手机中是否安装了APP2 if ([[UIApplication sharedApplication] canOpenURL:appURL]) &#123; //打开APP2 [[UIApplication sharedApplication] openURL:appURL]; &#125;else&#123; NSLog(@\"没有安装APP2\"); &#125; // ---------------如果是iOS9之前，上面代码就可以实现跳转了--------------------- // ---------------iOS9之后需要在应用程序中加上白名单，即在APP-1中加上APP-2的白名单--------- // ----------------在APP-1的Info中 添加键值对LSApplicationQueriesSchemes---------------------------------&#125; 在iOS9之后，跳转 我们需要在APP中设置需要跳转的URL Schemes才能实现跳转 即在Info中添加LSApplicationQueriesSchemes键值对 然后我们就可以实现跳转了 一个APP跳到另一个APP的指定页面这个实现起来也很简单的，首先在APP2中新建两个ViewController然后在APP-1中添加两个按钮分别是跳转到不同的页面 123456789UIButton *btn1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 200, 30)];[btn1 setTitle:@\"跳转到第一个界面\" forState:UIControlStateNormal];[btn1 addTarget:self action:@selector(jumpToApp2_1) forControlEvents:UIControlEventTouchUpInside];btn1.backgroundColor = [UIColor redColor];[self.view addSubview:btn1];UIButton *btn2 = [[UIButton alloc] initWithFrame:CGRectMake(50, 200, 200, 30)];[btn2 setTitle:@\"跳转到第二个界面\" forState:UIControlStateNormal];[btn2 addTarget:self action:@selector(jumpToApp2_2) forControlEvents:UIControlEventTouchUpInside];btn2.backgroundColor = [UIColor redColor]; 跳转事件 12345678910111213141516171819202122232425262728- (void)jumpToApp2_1&#123; //获取APP2的URL Scheme NSURL *appURL = [NSURL URLWithString:@\"APP2://VC1\"]; //判断手机中是否安装了APP2 if ([[UIApplication sharedApplication] canOpenURL:appURL]) &#123; //打开APP2的ViewController1 [[UIApplication sharedApplication] openURL:appURL]; &#125;else&#123; NSLog(@\"没有安装APP2\"); &#125;// ---------------如果是iOS9之前，上面代码就可以实现跳转了---------------------// ---------------iOS9之后需要在应用程序中加上白名单，即在APP-1中加上APP-2的白名单---------// ----------------在APP-1的Info中 添加键值对LSApplicationQueriesSchemes---------------------------------&#125;- (void)jumpToApp2_2&#123; //获取APP2的URL Scheme NSURL *appURL = [NSURL URLWithString:@\"APP2://VC2\"]; //判断手机中是否安装了APP2 if ([[UIApplication sharedApplication] canOpenURL:appURL]) &#123; //打开APP2ViewController2 [[UIApplication sharedApplication] openURL:appURL]; &#125;else&#123; NSLog(@\"没有安装APP2\"); &#125; // ---------------如果是iOS9之前，上面代码就可以实现跳转了--------------------- // ---------------iOS9之后需要在应用程序中加上白名单，即在APP-1中加上APP-2的白名单--------- // ----------------在APP-1的Info中 添加键值对LSApplicationQueriesSchemes---------------------------------&#125; 通过对跳转的协议头添加不同的描述，来实现不同的跳转 然后我们在APP-2的delegate中 实现方法 123456789101112131415161718// 因为现在xcode8 最低支持8.0 所以 我还是用这个方法吧-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; //获取根控制器 UINavigationController *nvc = (UINavigationController *)self.window.rootViewController;// ViewController *vc = nvc.childViewControllers.firstObject; //每次跳转都必须要在根控制器 这一点比较重要 [nvc popToRootViewControllerAnimated:YES]; //根据url判断需要展示的VC if ([url.absoluteString containsString:@\"VC1\"]) &#123; ViewController1 *vc1 = [[ViewController1 alloc] init];// [vc presentViewController:vc1 animated:YES completion:nil]; [nvc pushViewController:vc1 animated:YES]; &#125;else if([url.absoluteString containsString:@\"VC2\"])&#123; ViewController2 *vc2 = [[ViewController2 alloc] init]; [nvc pushViewController:vc2 animated:YES]; &#125; return YES;&#125; 实现跳转监听，这样就能跳转到不同的页面了 源代码放在了 https://github.com/yangqian111/blog/tree/master/APP-1 https://github.com/yangqian111/blog/tree/master/APP-2","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"IOS-批量获取文件名","date":"2016-10-28T01:18:54.000Z","path":"2016/10/28/IOS-批量获取文件名/","text":"IOS-批量获取文件名 批量获取文件名有一个需求要获取一个文件夹里面1000文件的名称，并且不要后缀，以前第一感觉要哭了，这得搞到什么时候啊，要暗无天日了。不过现在身为合格Coding，再像以前那样，就会比较二了。几句简单的代码就可以搞定了 12345678910111213141516NSString *path = @\"/Users/greatrong/Desktop/图片\";//文件目录NSFileManager *file = [NSFileManager defaultManager];NSArray *pathArray = [file contentsOfDirectoryAtPath:path error:nil];//获取所有的文件名加后缀NSLog(@\"pathArray %@\",pathArray);NSMutableArray *array = [[NSMutableArray alloc] init];for (NSString *str in pathArray) &#123;//遍历所有的文件名NSArray *b = [str componentsSeparatedByString:@\".\"];//以逗号隔开获取第一个元素 搞定 easyNSString *aaa = b.firstObject;[array addObject:aaa];&#125;NSLog(@\"NSString *aa %@\",array); 对文件的操作12345678910111213141516171819202122232425262728NSString *path = @\"/Users/greatrong/Desktop/图片\";NSFileManager *file = [NSFileManager defaultManager];BOOL isPath = [file fileExistsAtPath:path]; //判断文件夹是否存在BOOL isRead = [file isReadableFileAtPath:path];//是否可读BOOL isWrita = [file isWritableFileAtPath:path];//是否可写BOOL isExecu = [file isExecutableFileAtPath:path];//是否可执行文件BOOL isDele = [file isDeletableFileAtPath:path];//是否可删除//获取文件相关属性NSDictionary *dict = [file attributesOfItemAtPath:path error:nil];NSLog(@\"文件创建时间 %@\",[dict fileCreationDate]);NSLog(@\"文件属主账户为：%@\",[dict fileOwnerAccountName]);NSLog(@\"文件大小为：%lld\",[dict fileSize]);// 直接获取文件内容NSData *data = [file contentsAtPath:path];// 直接将NSData的数据用UTF-8的格式转换字符串NSString *content = [[NSString alloc] initWithData:dataencoding:NSUTF8StringEncoding];NSLog(@\"----------输出文件内容--------- %@\",content);if (isPath)&#123;NSLog(@\"存在\");&#125;else&#123;NSLog(@\"不存在\");&#125; 1234567891011121314151617181920212223242526//创建目录/*createDirectoryAtPath 路径withIntermediateDirectories 自动创建路径中所有的文件夹attributes 文件夹属性error 错误信息*/BOOL isCreat = [file createDirectoryAtPath:@\"/Users/greatrong/Desktop\" withIntermediateDirectories:NO attributes:nil error:nil];if (isCreat) &#123;NSLog(@\"创建成功\");&#125;BOOL isCopy = [file copyItemAtPath:@\"/Users/greatrong/Desktop/图片\" toPath:@\"/Users/greatrong/Desktop/2016-08-31\" error:nil];if (isCopy) &#123;NSLog(@\"复制成功\");&#125;BOOL isMove = [file moveItemAtPath:@\"/Users/greatrong/Desktop/图片/0bb8f4cc39de50336a21c21de8f856d9.jpg\" toPath:@\"/Users/greatrong/Desktop\" error:nil];if (isMove) &#123;NSLog(@\"移动成功\");&#125;BOOL isRemove = [file removeItemAtPath:@\"/Users/greatrong/Desktop/图片\" error:nil];if (isRemove) &#123;NSLog(@\"删除文件成功\");&#125; 除了我们利用代码 我们还可以利用一些命令行来来获取所有文件夹名称1ls | grep .png&amp; |cut -d . -f 1 打印(ls) 以.为分割线 分成两块 取第一块","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"},{"name":"文件操作","slug":"文件操作","permalink":"http://gezhenrong.cn/tags/文件操作/"}]},{"title":"swift 学习总结","date":"2016-10-14T06:16:09.000Z","path":"2016/10/14/swift-学习总结/","text":"swift 学习总结 字符串如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称声明中的冒号代表着“是…类型”你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：var red, green, blue: Double 类型别名typealias关键字来定义类型别名定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名 typealias AudioSample = UInt16var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound 现在是 0AudioSample被定义为UInt16的一个别名。因为它是别名，AudioSample.min实际上是UInt16.min，所以会给maxAmplitudeFound赋一个初值0 类型别名ypealias关键字来定义类型别名定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名typealias AudioSample = UInt16var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound 现在是 0AudioSample被定义为UInt16的一个别名。因为它是别名，AudioSample.min实际上是UInt16.min，所以会给maxAmplitudeFound赋一个初值0 整数和浮点数转换常量 three 的值被用来创建一个 Double 类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加 元组(tuple)元组是多个值组成的复合值类型元组内的值可以是任意类型，并不要求是相同类型元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组 可选类型使用可选类型（optionals）来处理值可能缺失的情况构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个 Int一个可选的 Int 被写作Int? 而不是 Int。问号暗示包含的值是可选类型，也就是说可能包含 Int 值也可能不包含值你可以给可选变量赋值为nil来表示它没有值如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nilvar surveyAnswer: String?// surveyAnswer 被自动设置为 nil在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为nil，不只是对象类型当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它 这被称为可选值的强制解析if convertedNumber != nil {print(“convertedNumber has an integer value of (convertedNumber!).”)}// 输出 “convertedNumber has an integer value of 123.”使用 ! 来获取一个不存在的可选值会导致运行时错误。使用 ! 来强制解析值之前，一定要确定可选包含一个非nil 的值 枚举经常被用于字符的替换.比如把枚举转化为字符结构体与雷达 相同点 都可以将多个数据封装为一个整体不同点 结构体只能封装数据，而类还可以封装属性赋值 结构体是拷贝 对象之间是深拷贝C语言中的枚举指定相关名称为一组整数值Swift 还增加了可选（Optional）类型，用于处理值缺失的情况 可选类型比 但是它可以用在任何类型上，不仅仅是类Objective-C 中的nil指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分 使用可选绑定 来判断可选类型是否包含值 隐式解析可选类型有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别：let possibleString: String? = “An optional string.”let forcedString: String = possibleString! // 需要惊叹号来获取值 let assumedString: String! = “An implicitly unwrapped optional string.”let implicitString: String = assumedString // 不需要感叹号你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。 集合(Set)用来存储相同类型并且没有确定顺序的值当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"},{"name":"学习","slug":"学习","permalink":"http://gezhenrong.cn/tags/学习/"},{"name":"Swift","slug":"Swift","permalink":"http://gezhenrong.cn/tags/Swift/"}]},{"title":"iOS 经验总结","date":"2016-10-08T01:44:38.000Z","path":"2016/10/08/iOS-经验总结/","text":"iOS 经验总结 UITableViewCell 文字、实现图片左右排版12345678910111213141516-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *cellId = @\"cellId\";UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellId];if (cell == nil) &#123;cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId];&#125;cell.textLabel.text = @\"12131\";//右边设置图片UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@\"icon_boke_\"]];cell.accessoryView = imageView;//左边设置图片cell.imageView.image = [UIImage imageNamed:@\"icon_boke_\"];return cell;&#125; 导航栏隐藏 1[self.navigationController setHidden] 隐藏Status bar（状态栏） 1[[UIApplication sharedApplication] setStatusBarHidden:YES]; 隐藏NavigationBar（导航栏） 1[self.navigationController setNavigationBarHidden:YES animated:YES]; 隐藏tabBarController（标签栏） 尺寸改成大于480就OK。 1[self.tabBarController.view setFrame:CGRectMake(0, 0, 320, 520)]; 字符串转化为json字符串1234NSMutableDictionary *dictionary = [[NSMutableDictionary alloc] init];[dictionary setValue:guessArray forKey:@\"numbers\"];NSData *data=[NSJSONSerialization dataWithJSONObject:[dictionary toJSONData] options:NSJSONWritingPrettyPrinted error:nil];NSString *jsonStr=[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; ios app 第一次进入123456if (![[NSUserDefaults standardUserDefaults] boolForKey:@\"everLaunched\"]) &#123; [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@\"everLaunched\"]; [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@\"firstLaunch\"]; &#125;else&#123; [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@\"firstLaunch\"]; &#125; 合成图片12345678910111213- (UIImage *)addImage:(UIImage *)image1 toImage:(UIImage *)image2 &#123; UIGraphicsBeginImageContext(image1.size); // Draw image1 [image1 drawInRect:CGRectMake(0, 0, image1.size.width, image1.size.height)]; // Draw image2 [image2 drawInRect:CGRectMake(0, 0, image2.size.width, image2.size.height)]; UIImage *resultingImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return resultingImage; &#125; 进入AppStore搜索页面1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/search\"]]; 设备唯一标识符1NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; 遍历数组的所有元素1234[self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;[str appendFormat:@\"%@,\\n\", obj];&#125;]; IOS 等比例压缩图片123456789101112131415161718192021222324252627282930313233343536373839404142-(UIImage *) imageCompressForSize:(UIImage *)sourceImage targetSize:(CGSize)size&#123; UIImage *newImage = nil; CGSize imageSize = sourceImage.size; CGFloat width = imageSize.width; CGFloat height = imageSize.height; CGFloat targetWidth = size.width; CGFloat targetHeight = size.height; CGFloat scaleFactor = 0.0; CGFloat scaledWidth = targetWidth; CGFloat scaledHeight = targetHeight; CGPoint thumbnailPoint = CGPointMake(0.0, 0.0); if(CGSizeEqualToSize(imageSize, size) == NO)&#123; CGFloat widthFactor = targetWidth / width; CGFloat heightFactor = targetHeight / height; if(widthFactor &gt; heightFactor)&#123; scaleFactor = widthFactor; &#125; else&#123; scaleFactor = heightFactor; &#125; scaledWidth = width * scaleFactor; scaledHeight = height * scaleFactor; if(widthFactor &gt; heightFactor)&#123; thumbnailPoint.y = (targetHeight - scaledHeight) * 0.5; &#125;else if(widthFactor &lt; heightFactor)&#123; thumbnailPoint.x = (targetWidth - scaledWidth) * 0.5; &#125; &#125; UIGraphicsBeginImageContext(size); CGRect thumbnailRect = CGRectZero; thumbnailRect.origin = thumbnailPoint; thumbnailRect.size.width = scaledWidth; thumbnailRect.size.height = scaledHeight; [sourceImage drawInRect:thumbnailRect]; newImage = UIGraphicsGetImageFromCurrentImageContext(); if(newImage == nil)&#123; NSLog(@\"scale image fail\"); &#125; UIGraphicsEndImageContext(); return newImage; &#125; iOS 跳转到系统的设置界面在需要调转的按钮动作中添加如下的代码，就会跳转到设置中自己的app的设置界面，这里会有通知和位置权限的设置 123456//定位服务设置界面NSURL *url = [NSURL URLWithString:@\"prefs:root=LOCATION_SERVICES\"];if ([[UIApplication sharedApplication] canOpenURL:url])&#123;[[UIApplication sharedApplication] openURL:url];&#125; 看到这几个例子，大家有没有发现，想跳到哪个设置界面只需要prefs:root=后面的值即可！是的，就是这样的。我在网上找到一个列表，可以跳到这些界面的参数配置： 1234567891011121314151617181920212223242526272829303132333435363738蜂窝网络：prefs:root=MOBILE_DATA_SETTINGS_IDVPN — prefs:root=General&amp;path=Network/VPNWi-Fi：prefs:root=WIFI定位服务：prefs:root=LOCATION_SERVICES个人热点：prefs:root=INTERNET_TETHERING关于本机：prefs:root=General&amp;path=About辅助功能：prefs:root=General&amp;path=ACCESSIBILITY飞行模式：prefs:root=AIRPLANE_MODE锁定：prefs:root=General&amp;path=AUTOLOCK亮度：prefs:root=Brightness蓝牙：prefs:root=General&amp;path=Bluetooth时间设置：prefs:root=General&amp;path=DATE_AND_TIMEFaceTime：prefs:root=FACETIME设置：prefs:root=General键盘设置：prefs:root=General&amp;path=KeyboardiCloud：prefs:root=CASTLEiCloud备份：prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP语言：prefs:root=General&amp;path=INTERNATIONAL定位：prefs:root=LOCATION_SERVICES音乐：prefs:root=MUSICMusic Equalizer — prefs:root=MUSIC&amp;path=EQMusic Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimitNetwork — prefs:root=General&amp;path=NetworkNike + iPod — prefs:root=NIKE_PLUS_IPODNotes — prefs:root=NOTESNotification — prefs:root=NOTIFICATIONS_IDPhone — prefs:root=PhonePhotos — prefs:root=PhotosProfile —prefs:root=General&amp;path=ManagedConfigurationListReset — prefs:root=General&amp;path=ResetSafari — prefs:root=SafariSiri — prefs:root=General&amp;path=AssistantSounds — prefs:root=SoundsSoftware Update —prefs:root=General&amp;path=SOFTWARE_UPDATE_LINKStore — prefs:root=STORETwitter — prefs:root=TWITTERUsage — prefs:root=General&amp;path=USAGEWallpaper — prefs:root=Wallpaper 进入appstore中指定的应用1234NSString *str = [NSString stringWithFormat: @\"itms-apps://ax.itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=%d\", myAppID ]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]]; iOS应用内跳转到appstore里评分12NSString *evaluateString = [NSString stringWithFormat:@\"itms-apps://ax.itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=%d\",myAppID];[[UIApplication sharedApplication] openURL:[NSURL URLWithString:evaluateString]]; iOS导航栏的背景颜色设置 默认 self.navigationController.navigationBar.barStyle = UIBarStyleDefault;123self.navigationController.navigationBar.translucent = YES;self.navigationController.navigationBar.tintColor = nil; //[self.navigationController.navigationBar setBarTintColor:[UIColor blueColor]];// 黑色不透明 123self.navigationController.navigationBar.barStyle = UIBarStyleBlack; self.navigationController.navigationBar.translucent = NO; self.navigationController.navigationBar.tintColor = [UIColor whiteColor]; 黑色透明 123self.navigationController.navigationBar.barStyle = UIBarStyleBlack;self.navigationController.navigationBar.translucent = YES;self.navigationController.navigationBar.tintColor = [UIColor whiteColor]; 项目中出现的问题UIView被removeFromSuperview的时候，这时候界面还存在， 首先分析view是不是加载在self.view上的 判断view是不是被多次加载 分析多次加载view的原因，解决的方法是在加载view之前将view remove掉 12UIView *tagView = [fromVC.view viewWithTag:1000];//根据tag值判断 [tagView removeFromSuperview]; 12345 for (UIView *view in fromVC.view.subviews) &#123; if ([view isKindOfClass:[YMDOrderPayView class]]) &#123; [view removeFromSuperview] &#125;&#125;//根据for循环判断是否是这个类 禁止手机睡眠 1[UIApplication sharedApplication].idleTimerDisabled = YES; 编译的时候遇到 no such file or directory: ／users／apple／XXX 1答：是因为编译的时候，在此路径下找不到这个文件，解决这个问题，首先是是要检查缺少的文件是不是在工程中，如果不在工程中，需要从本地拖进去，如果发现已经存在工程中了，或者拖进去还是报错，这时候需要去build phases中搜索这个文件，这时候很可能会搜出现两个相同的文件，这时候，有一个路径是正确的，删除另外一个即可。如果删除了还是不行，需要把两个都删掉，然后重新往工程里拖进这个文件即可 颜色转换成图片 12345678910111213+ (UIImage *)cl_imageWithColor:(UIColor *)color &#123; CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 获取app缓存大小 12345678910111213141516171819- (CGFloat)getCachSize &#123; NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize]; //获取自定义缓存大小 //用枚举器遍历 一个文件夹的内容 //1.获取 文件夹枚举器 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@\"Library/Caches\"]; NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath]; __block NSUInteger count = 0; //2.遍历 for (NSString *fileName in enumerator) &#123; NSString *path = [myCachePath stringByAppendingPathComponent:fileName]; NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]; count += fileDict.fileSize;//自定义所有缓存大小 &#125; // 得到是字节 转化为M CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024; return totalSize;&#125; 清理app缓存 1234567891011- (void)handleClearView &#123; //删除两部分 //1.删除 sd 图片缓存 //先清除内存中的图片缓存 [[SDImageCache sharedImageCache] clearMemory]; //清除磁盘的缓存 [[SDImageCache sharedImageCache] clearDisk]; //2.删除自己缓存 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@\"Library/Caches\"]; [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil];&#125; 常用权限判断 1234567891011121314151617if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) &#123; NSLog(@\"没有定位权限\");&#125;AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];if (statusVideo == AVAuthorizationStatusDenied) &#123; NSLog(@\"没有摄像头权限\");&#125;//是否有麦克风权限AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];if (statusAudio == AVAuthorizationStatusDenied) &#123; NSLog(@\"没有录音权限\");&#125;[PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) &#123; if (status == PHAuthorizationStatusDenied) &#123; NSLog(@\"没有相册权限\"); &#125;&#125;]; 获取手机和app信息 12345678910111213141516171819202122232425262728293031323334353637NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; CFShow(infoDictionary); // app名称 NSString *app_Name = [infoDictionary objectForKey:@\"CFBundleDisplayName\"]; // app版本 NSString *app_Version = [infoDictionary objectForKey:@\"CFBundleShortVersionString\"]; // app build版本 NSString *app_build = [infoDictionary objectForKey:@\"CFBundleVersion\"]; //手机序列号 NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier]; NSLog(@\"手机序列号: %@\",identifierNumber); //手机别名： 用户定义的名称 NSString* userPhoneName = [[UIDevice currentDevice] name]; NSLog(@\"手机别名: %@\", userPhoneName); //设备名称 NSString* deviceName = [[UIDevice currentDevice] systemName]; NSLog(@\"设备名称: %@\",deviceName ); //手机系统版本 NSString* phoneVersion = [[UIDevice currentDevice] systemVersion]; NSLog(@\"手机系统版本: %@\", phoneVersion); //手机型号 NSString* phoneModel = [[UIDevice currentDevice] model]; NSLog(@\"手机型号: %@\",phoneModel ); //地方型号 （国际化区域名称） NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel]; NSLog(@\"国际化区域名称: %@\",localPhoneModel ); NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; // 当前应用名称 NSString *appCurName = [infoDictionary objectForKey:@\"CFBundleDisplayName\"]; NSLog(@\"当前应用名称：%@\",appCurName); // 当前应用软件版本 比如：1.0.1 NSString *appCurVersion = [infoDictionary objectForKey:@\"CFBundleShortVersionString\"]; NSLog(@\"当前应用软件版本:%@\",appCurVersion); // 当前应用版本号码 int类型 NSString *appCurVersionNum = [infoDictionary objectForKey:@\"CFBundleVersion\"]; NSLog(@\"当前应用版本号码：%@\",appCurVersionNum); 获取一个类的所有属性 1234567id LenderClass = objc_getClass(\"Lender\");unsigned int outCount, i;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);for (i = 0; i &lt; outCount; i++) &#123; objc_property_t property = properties[i]; fprintf(stdout, \"%s %s\\n\", property_getName(property), property_getAttributes(property));&#125; 身份证号验证 12345678910- (BOOL)validateIdentityCard &#123; BOOL flag; if (self.length &lt;= 0) &#123; flag = NO; return flag; &#125; NSString *regex2 = @\"^(\\\\d&#123;14&#125;|\\\\d&#123;17&#125;)(\\\\d|[xX])$\"; NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",regex2]; return [identityCardPredicate evaluateWithObject:self];&#125; 合并两个图片 123456789101112131415+ (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage &#123; CGImageRef firstImageRef = firstImage.CGImage; CGFloat firstWidth = CGImageGetWidth(firstImageRef); CGFloat firstHeight = CGImageGetHeight(firstImageRef); CGImageRef secondImageRef = secondImage.CGImage; CGFloat secondWidth = CGImageGetWidth(secondImageRef); CGFloat secondHeight = CGImageGetHeight(secondImageRef); CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight)); UIGraphicsBeginImageContext(mergedSize); [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)]; [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 画水印 1234567891011121314- (void) setImage:(UIImage *)image withWaterMark:(UIImage *)mark inRect:(CGRect)rect&#123; if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 4.0) &#123; UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0); &#125; //原图 [image drawInRect:self.bounds]; //水印图 [mark drawInRect:rect]; UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); self.image = newPic;&#125; 获取视频的时长 1234567+ (NSInteger)getVideoTimeByUrlString:(NSString *)urlString &#123; NSURL *videoUrl = [NSURL URLWithString:urlString]; AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl]; CMTime time = [avUrl duration]; int seconds = ceil(time.value/time.timescale); return seconds;&#125; -[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0 1这是一个经典错误，ViewController不能响应aMethod这个方法，错误原因可能viewController文件中没有实现aMethod这个方法 让手机震动一下 1234#importAudioServicesPlayAlertSound(kSystemSoundID_Vibrate);或者AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); 将一个image保存在相册中 1234567891011121314UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);或者#import[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123; PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image]; changeRequest.creationDate = [NSDate date]; &#125; completionHandler:^(BOOL success, NSError *error) &#123; if (success) &#123; NSLog(@\"successfully saved\"); &#125; else &#123; NSLog(@\"error saving to photos: %@\", error); &#125; &#125;]; UITextView中打开或禁用复制，剪切，选择，全选等功能 1234567891011121314151617181920// 继承UITextView重写这个方法- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123;// 返回NO为禁用，YES为开启 // 粘贴 if (action == @selector(paste:)) return NO; // 剪切 if (action == @selector(cut:)) return NO; // 复制 if (action == @selector(copy:)) return NO; // 选择 if (action == @selector(select:)) return NO; // 选中全部 if (action == @selector(selectAll:)) return NO; // 删除 if (action == @selector(delete:)) return NO; // 分享 if (action == @selector(share)) return NO; return [super canPerformAction:action withSender:sender];&#125; runtime为一个类动态添加属性 12// 动态添加属性的本质是: 让对象的某个属性与值产生关联 objc_setAssociatedObject(self, WZBPlaceholderViewKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC); KVO监听某个对象的属性 12345678910// 添加监听者[self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil];// 当监听的属性值变化的时候会来到这个方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if ([keyPath isEqualToString:@\"property\"]) &#123; [self textViewTextChange]; &#125; else &#123; &#125;&#125; 网络监测 12345678910NetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus]; if (status == NotReachable) &#123; NSLog(@\"当前设备无网络\"); &#125; if (status == ReachableViaWiFi) &#123; NSLog(@\"当前wifi网络\"); &#125; if (status == NotReachable) &#123; NSLog(@\"当前蜂窝移动网络\"); &#125; 1、获取当前日期、时间 1234NSDate *currentDate = [NSDate date];NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@\"YYYY-MM-dd\"];NSString *currentDateStr = [dateFormatter stringFromDate:currentDate]; 2、获取一周前的日期、时间 12345678NSDate * date = [NSDate date];NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@\"yyyy-MM-dd\"];//一周的秒数NSTimeInterval time = 7 * 24 * 60 * 60;//下周就把\"-\"去掉NSDate *lastWeek = [date dateByAddingTimeInterval:-time];NSString *startDate = [dateFormatter stringFromDate:lastWeek]; 3、比较两个日期大小 123456789101112131415161718192021222324252627282930313233343536//比较两个日期大小-(int)compareDate:(NSString*)startDate withDate:(NSString*)endDate&#123; int comparisonResult; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@\"yyyy-MM-dd\"]; NSDate *date1 = [[NSDate alloc] init]; NSDate *date2 = [[NSDate alloc] init]; date1 = [formatter dateFromString:startDate]; date2 = [formatter dateFromString:endDate]; NSComparisonResult result = [date1 compare:date2]; NSLog(@\"result==%ld\",(long)result); switch (result) &#123; //date02比date01大 case NSOrderedAscending: comparisonResult = 1; break; //date02比date01小 case NSOrderedDescending: comparisonResult = -1; break; //date02=date01 case NSOrderedSame: comparisonResult = 0; break; default: NSLog(@\"erorr dates %@, %@\", date1, date2); break; &#125; return comparisonResult;&#125; int comparisonResult = [self compareDate:startDate withDate:endDate];if(comparisonResult &gt;0)&#123; //endDate 大&#125; 4、比较日期差 123456789101112131415//比较两个日期大小-(NSInteger)compare:(NSDate *)startTime to:(NSDate *)endTime&#123; // 当前日历 NSCalendar *calendar = [NSCalendar currentCalendar]; // 需要对比的时间数据 NSCalendarUnit unit = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond; // 对比时间差 NSDateComponents *dateCom = [calendar components:unit fromDate:startTime toDate:endTime options:0]; NSString *time = [NSString stringWithFormat:@\"%ld%ld%ld%ld%ld%ld\",dateCom.year,dateCom.month,dateCom.day,dateCom.hour,dateCom.minute,dateCom.second]; NSLog(@\"time----&gt;%@\",time); return [time integerValue];&#125; 5、时间和时间戳的转换 12345678910111213141516//获取系统时间戳 NSDate* date1 = [NSDate date]; NSTimeInterval time1 =[date1 timeIntervalSince1970]; NSString *timeString = [NSString stringWithFormat:@\"%.0f\",time1]; NSLog(@\"系统时间戳:%@\",timeString); //时间戳转换成时间 NSTimeInterval time2 =[timeString doubleValue]; NSDate *date2 = [NSDate dateWithTimeIntervalSince1970:time2]; NSLog(@\"date2 = %@\",date2); NSDateFormatter *formatter = [[NSDateFormatter alloc]init]; [formatter setDateFormat:@\"yyyy/MM/dd\"]; NSString *currentTime = [formatter stringFromDate:date2]; NSLog(@\"当前时间:%@\",currentTime); //时间转时间戳 NSString *timeStr = [NSString stringWithFormat:@\"%.0f\",[date2 timeIntervalSince1970]];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"hexo + Github 搭建个人博客","date":"2016-09-30T02:31:24.000Z","path":"2016/09/30/hexo-Github-搭建个人博客/","text":"hexo + Github 搭建个人博客 Hexo详解什么是HexoHexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上快速、简单且功能强大的 Node.js 博客框架 GitHub Pages是什么？GitHub Pages 可以被认为是用户编写的、托管在github上的静态网页。由于它的空间免费稳定， 可以用于介绍托管在github上的Project或者搭建网站 Hexo 的安装 由于 Hexo 是基于 Node ，安装前要先安装 Node 安装Hexo，要用全局安装，加-g参数。:npm install -g hexo 查看命令帮助： 1、 help ： 查看帮助信息 2、 init [文件夹名] ： 创建一个hexo项目，不指定文件夹名，则在当前目录创建 3、 version ： 查看hexo的版本 4、 –config config-path ：指定配置文件，代替默认的_config.yml 5、 –cwd cwd-path ：自定义当前工作目录 6、 –debug ：调试模式，输出所有日志信息 7、 –safe ：安全模式，禁用所有的插件和脚本 8、 –silent ：无日志输出模式 Hexo的配置目录和文件 1、 scaffolds ：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局： post 、 page 和 draft ，它们分别对应不同的路径。新建文件的默认布局是 post ，可以在配置文件中更改布局。用 draft 布局生成的文件会被保存到 source/_drafts 文件夹。 2、 source ：资源文件夹是存放用户资源的地方。 3、 source/_post ：文件箱。（低版本的hexo还会存在一个 _draft ，这是草稿箱）除 posts 文件夹之外，开头命名为 (下划线)的文件/ 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 4、 themes ：主题 文件夹。Hexo 会根据主题来生成静态页面。 5、 themes/landscape ：默认的皮肤文件夹 6、 _config.yml ：全局的配置文件，每次更改要重启服务。低版本的Hexo还会生成scripts文件夹，里面用于保存扩展Hexo的脚本文件。 全局配置可以在 _config.yml 中修改： Hexo Configuration Docs: http://hexo.io/docs/configuration.html Source: https://github.com/hexojs/hexo/ Site 站点配置 title: Hexo-demo #网站标题subtitle: hexo is simple and easy to study #网站副标题description: this is hexo-demo #网栈描述author: pomy #你的名字language: zh-CN #网站使用的语言timezone: Asia/Shanghai #网站时区 URL #可以不用配置 If your site is put in a subdirectory, set url as ‘http://yoursite.com/child‘ and root as ‘/child/‘ url: http://yoursite.com #网址，搜索时会在搜索引擎中显示root: / #网站根目录permalink: :year/:month/:day/:title/ #永久链接格式permalink_defaults: #永久链接中各部分的默认值 Directory 目录配置source_dir: source #资源文件夹，这个文件夹用来存放内容 public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件 tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径 Writing 写作配置 new_post_name: :title.md # 新文章的文件名称default_layout: post #默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #是否启动资源文件夹relative_link: false #把链接改为与根目录的相对位址future: truehighlight: #代码块的设置enable: trueline_number: trueauto_detect: truetab_replace Category &amp; Tag 分类 &amp; 标签 default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名 Date / Time format 时间和日期Hexo uses Moment.js to parse and display date You can customize the date format as defined inhttp://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss Pagination 分页Set per_page to 0 to disable pagination per_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录 Extensions 扩展Plugins: http://hexo.io/plugins/ 插件 Themes: http://hexo.io/themes/ 主题 theme: landscape #当前主题名称 Deployment 部署到github Docs: http://hexo.io/docs/deployment.html deploy: type:","tags":[{"name":"学习","slug":"学习","permalink":"http://gezhenrong.cn/tags/学习/"}]},{"title":"CocoaPods 1.0 + 适配","date":"2016-09-26T01:55:43.000Z","path":"2016/09/26/CocoaPods 1.0 + 适配/","text":"CocoaPods 1.0 + 适配 CocoaPods 1.0 + 适配原文连接! CocoaPods 1.0 发布4个多月了。之前的写的笔记过时了，抽空更新一波。同时解决一下图片不能看的问题。鉴于写完之前的总结之后很多人问我怎么弄私有 Pod ，今天会写一下。 目录 CocoaPods 1.0 安装及适配 利用 CocoaPods 发布自己的三方库 CocoaPods 1.0 私有 Pods CocoaPods 1.0 安装及适配 如何安装？命令行中输入 sudo gem install cocoapods 遇到 Operation not permitted - /usr/bin/pod 可以参照这里 有何变化？[没用过旧版的可以忽略] 必须指明 target :exclusive =&gt; true 和 link_with 被去掉了 使用本地的 pod 只能使用 :path pod install 不再更新本地 repo pod install –repo-update 更新本地 repo 在安装 pods 利用CocoaPods发布自己的三方库 将自己的三方库集成 CocoaPods 只需要三步 初始化项目 创建和编写 podspec 将 podspec 上传到 CocoaPods 的 repo 上 1.初始化项目 原理上 Cocoapods 支持任意源代码管理(例如 git svn)的开源仓库。只要用户可以根据 url 下载到项目的网址都可以。所以不局限于GitHub。但是今天我们以 GitHub 为例。 项目初始化结束之后,需要给项目打 tag 以便告诉 Cocoapods 自己项目的最新版。每发一版需要一个 tag1234567// push to remotegit add .git commit -m \"初始化项目\"git push//add tag git tag -m \"2rd release\" 0.2.0git push --tags 2.创建和编写 podspec [ 最重要的一步 ] 你可以创建一个名字叫做 XXX.podspec 空文件。 也可以通过 pod spec create DWCategorygit@github.com:Damonvvong/DWCategory.git 创建一个有备注的 podspec 编写 podspec 文件：123456789101112131415Pod::Spec.new do |s| s.name = \"DWCategory\" # 名称 s.version = \"0.2.0\" # 版本号，git 的 tag s.summary = \"一个简单的分类用于测试 Cocoapods 1.0 +\" s.description = &lt; - 测试 pod - Cocoapods 1.0 - description 需要比 summary 长 DESC s.homepage = \"https://github.com/Damonvvong\" s.license = &#123; :type =&gt; \"MIT\", :file =&gt; \"LICENSE\" &#125; # 开源协议 s.author = &#123; \"Damonwong\" =&gt; \"coderonevv@gmail.com\" &#125; s.platform = :ios, \"8.0\" # 支持的平台及版本 s.source = &#123; :git =&gt; \"https://github.com/Damonvvong/DWCategory.git\", :tag =&gt; \"#&#123;s.version&#125;\" &#125; 项目地址作为开源项目，这里不能使用 ssh1234s.source_files = \"DWCategory\", \"DWCategory/**/*.&#123;h,m&#125;\" # 模块文件路径配置 s.exclude_files = \"Classes/Exclude\" s.module_name = 'DWCategory' # 模块名称end 编写完运行 pod lib lint ，出现如下图 运行无误 将 podspec 上传到 CocoaPods 的 repo 上 利用 Trunk把自己的 DWCategory.podspec 文件上传给 Cocoapods 1.注册1pod trunk register coderonevv@gmail.com 'Damonwong' --verbose coderonevv@gmail.com：自己的邮箱 Damonwong：用户名（最好和.podspec 文件 中一样） 2.检查是否注册成功 登录邮箱，确认注册 检查注册情况：pod trunk me（看到类似下面，就是成功了）123pod trunk me - Name: Damonwong - Email: coderonevv@gmail.com 3.上传DWCategory.podspec 到 Cocoapods/repo 进入 文件所在文件夹 1cd /Users/damon/Desktop/DWCategory 上传文件 1pod trunk push /Users/damon/Desktop/DWCategory 4.上传完成，查找一下1pod search DWCategory Done! 现在可以用 pod ‘DWCategory’ 来导入了","tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://gezhenrong.cn/tags/CocoaPods/"}]},{"title":"好的代码集合","date":"2016-09-22T02:46:01.000Z","path":"2016/09/22/好的代码集合/","text":"好的代码集合 基于AVPlayer自定义播放器基于AVPlayer自定义播放器! 访问系统的通讯录，回调访问系统的通讯录，回调! 访问系统的通讯录，回调访问系统的通讯录，回调! 上下，左右形式跑马灯上下，左右形式跑马灯! 仿微信客户端 长按界面会自动识别二维码仿微信客户端 长按界面会自动识别二维码! iOS10新特性-最简单的iMessage application开发iOS10新特性-最简单的iMessage application开发! SmartPush推送开发大牛开发大牛 博客一款IOS苹果远程推送测试程序,Mac OS下的APNS工具APP,iOS Push Notification Debug App 中文 iOS/Mac开发博客列表有兴趣的可以浏览 弹幕系统实现弹幕系统实现 图片裁剪和一些基本的旋转图片裁剪和一些基本的旋转 拍照、选取、编辑图片于一身的精简拍照、选取、编辑图片于一身的精简 JSPatch常见问题JSPatch常见问题 RestKit一个用于更好支持RESTful风格服务器接口的iOS库 WebViewJavascriptBridge Objective-C 和 javascript 相互通信 RestKit导航栏的平滑显示和隐藏","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"}]},{"title":"iOS面试总结","date":"2016-09-21T01:12:38.000Z","path":"2016/09/21/面试总结/","text":"面试总结 uitableview， uicollectionView的复用 是怎么优化的 UITableView最核心的思想就是UITableViewCell的重用机制。简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。 uicollectionView的复用如果我们在CollectionView向数据源请求数据之前使用-registerNib:forCellReuseIdentifier:方法注册的话，就可以省下每次判断cell是否为空并初始化cell的代码，如果在重用队列里没有可用的cell的话，runtime（运行时）将自动帮我们生成并初始化一个可用的cell。 SDwebimage的是怎么实现的 当我门需要获取网络图片的时候，我们首先需要的便是URl没有URl什么都没有，获得URL后我们SDWebImage实现的并不是直接去请求网路，而是检查图片缓存中有没有和URl相关的图片，如果有则直接返回image，如果没有则进行下一步。当图片缓存中没有图片时，SDWebImage依旧不会直从网络上获取，而是检查沙盒中是否存在图片，如果存在，则把沙盒中对应的图片存进image缓存中，然后按着第一步的判断进行。如果沙盒中也不存在，则显示占位图，然后根据图片的下载队列缓存判断是否正在下载，如果下载则等待，避免二次下载。如果不存则创建下载队列，下载完毕后将下载操作从队列中清除，并且将image存入图片缓存中。 通知 代理 block的原理 代理 block：首先两者作用是一样的，都是进行单一回调。不通的是，delegate是个对象，然后用过一个对象自己调用代理协议函数来完成整个流程。 block是传递一个函数指针，利用函数指针执行来进行回调。还有在内存管理上需要注意，delegate不需要保存引用。block对引用数据有copy的处理。将block拷贝到堆上，数组中的block是栈上的对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制， ARC环境下：ARC环境下可以通过使用_weak声明一个代替self的新变量代替原先的self，我们可以命名为weakSelf。通过这种方式告诉block，不要在block内部对self进行强制strong引用解决方式与上述基本一致，只不过将weak关键字换成block即可，这样的意思是告诉block：小子，不要在内部对self进行retain了 1.block对象在block中是可以被修改、重新赋值的。2.block对象在block中不会被block强引用一次，从而不会出现循环引用问题。 weak修饰符的对象因此，block和__weak修饰符的区别其实是挺明显的： block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。 weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。 block对象可以在block中被重新赋值，weak不可以。使用弱引用 弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生 弱引用的实现原理弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与 Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为：我们在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型 strong与weak的区别 strong类似于retain，会将对象的引用计数器+1，分配内存地址。weak类似于指针，只是单纯的指向某个地址，但是本身并未分配内存地址。当指向的地址被销毁时，该指针会自动nil。 队列 串行队列：队列中的任务只会顺序执行 并行队列： 队列中的任务通常会并发执行； 全局队列：是系统的，直接拿过来（GET）用就可以；与并行队列类似； 主队列：每一个应用程序对应唯一主队列，直接GET即可；在多线程开发中，使用主队列更新UI； 本地存储有哪几种方式 归档 CocoData FMDB NSUerdefault plist 多线程有几种方法 NSThread：可以直接操控线程对象，它的生命周期还是需要我们手动管理GCD：会自动管理线程的生命周期，完全不需要我们管理NSOperation ###设计模式有几种 创建型：单例设计模式、抽象工厂设计模式结构型：MVC 模式、装饰器模式、适配器模式、外观模式、组合模式行为型：责任链设计模式、观察者设计模式，备忘录设计模式、命令设计模式 kvc kvo ###单例 单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。它通常采用懒加载的方式在第一次用到实例的时候再去创建它 ###单例模式实现步骤： 声明一个静态变量去保存类的实例，确保它在类中的全局可用性。声明一个静态变量dispatch_once_t ,它确保初始化器代码只执行一次使用Grand Central Dispatch(GCD)执行初始化LibraryAPI变量的block.这 正是单例模式的关键：一旦类已经被初始化，初始化器永远不会再被调用。 copy, retain, assign , readonly , readwrite,strong,weak,nonatomic整理 readwrite:表明这个属性是可读可写的readonly:表明这个属性只能读不能写copy:建立一个索引计数为1的对象，然后释放旧对象 对NSStringretain:释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1assign： 简单赋值，不更改索引计数retain：释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1atomic:表示是线程安全的。nonatomic:表示是非线程安全的，使用此属性性能会提高一些 属性readwrite, readonly, assign, retain, copy, nonatomic各是什么作用？在哪种情况下用？ 1.readwrite 是可读可写特性；需要生成getter方法和setter方法时（补充：默认属性，将生成不带额外参数的getter和setter方法（setter方法只有一个参数））2.readonly 是只读特性，只会生成getter方法，不会生成setter方法;不希望属性在类外改变3.assign 是赋值特性，setter方法将传入参数赋值给实例变量；仅设置变量时；4.retain(MRC)/strong(ARC) 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;5.copy 表示拷贝特性，setter方法将传入对象复制一份；需要完全一份新的变量时。6.nonatomic 非原子操作，决定编译器生成的setter和getter方法是否是原子操作。atomic表示多线程安全，需要对方法加锁，保证同一时间只有一个线程访问属性，因为有等待过程，所以影响执行效率一般使用nonatomic。不加锁。效率会更高。但是线程不安全 iOS9的适配 iOS9把所有的http请求都改为https了 可通过在 Info.plist 中声明如果不适配iOS9，就不能偷偷在后台定位（不带蓝条） 同一App中的多个location manager：一些只能在前台定位，另一些可在后台定位，并可随时开启或者关闭特定location manager的后台定位。 配置Info.plistiOS9之前，企业级分发十分方便：点击App出现“信任按钮”，iOS9以后，默认不能安装，也不再出现“信任按钮”在iOS9中，如果使用URL scheme必须在”Info.plist”中将你要在外部调用的URL scheme列为白名单，否则不能使用 谈谈你对MVC的理解？为什么要用MVC？在Cocoa中MVC是怎么实现的？你还熟悉其他的OC设计模式或别的设计模式吗？ mvc - model view controller 避免了view与model 的强耦合 使代码更灵活 更容易维护 可复用 可扩展 oc其他设计模式有Notification #import、#include和@class有什么区别 import 系统文件、自定义文件引用 不用担心重复引用的问题include 跟#import几乎一样 但是他需要注意不能重复引用@class 只是告诉系统有这个类 但是如果在实现类中用到这个类 需要重新用#import导入该类头文件此外@class和#import的主要区别在于解决引用死锁的问题 分别描述类别（categories）和延展（extensions）是什么？以及两者的区别？继承和类别在实现中有何区别？为什么Category只能为对象添加方法，却不能添加成员变量？ 考虑类目比继承的优点类别是把类的实现方法分散到不同的文件中 也可以给类扩展新方法延展是给类添加私有方法 只为自己类所见 所使用继承可以扩展实例变量 而类别不能类别如果可以添加成员变量 就跟继承没什么两样了 而且在上线的项目更新中 用类别笔继承更能维护项目的稳定性懒汉模式，只在用到的时候才去初始化。也可以理解成延时加载。我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。一个延时载，避免内存过高，一个异步加载，避免线程堵塞 在一个对象的方法里面：self.name = @”object”;和 _name = @”object”有什么不同吗？self.name = @”object”; 是通过点语法修改属性name的值。本质上使用的是name属性的setter方法进行的赋值操作，实际上执行的代码是 [self setName:@”object”]; 例如：12345678@property(nonatomic, strong) NSString *name;//根据@property关键词，系统自动生成setter方法。- (void)setName:(NSString *)name&#123;//根据strong关键词[name retain]; //内存计数+1[_name release]; //把之前指针指向的内容内存计数-1_name = name; //指向新内容&#125; _name = @“object”; 只是单纯的把‘_name’指针指向‘@”object”’字符串对象所在的地址，没有调用方法。 什么叫数据结构？ 数据结构是计算机存储、组织数据的方式。是指相互之间存在一种或多种特定关系的数据元素的集合。通常，精心选择的数据结构可以带来更高的运行或者存储效率。 OC如何对内存管理的，说说你的看法和解决方法。 Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。 1. 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。 2. 手动内存计数MRC：遵循内存谁申请，谁添加。谁释放的原则。 3. 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain) 池子中所有的内存空间也被自动释放掉。 内存池的释放操作分为自动和手动。自动释放受runloop机制影响。 浅拷贝和深拷贝的区别？ 浅拷贝：只复制指向对象的指针，而不复制引用对象本身。深拷贝：复制引用和对象本身。意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份。那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。用网上一哥们通俗的话将就是：浅拷贝好比你和你的影子，你完蛋，你的影子也完蛋深拷贝好比你和你的克隆人，你完蛋，你的克隆人还活着。 用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？ 因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本. 如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. get请求与post请求的区别 get是向服务器发索取数据的一种请求，而post是向服务器提交数据的一种请求 get请求的数据会暴露在地址栏中，而post请求不会，所以post请求的安全性比get请求号 get请求对url长度有限制，而post请求对url长度理论上是不会收限制的 谈谈你对多线程开发的理解？ios中有几种实现多线程的方法？ 使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片，视频的下载； 发挥多核处理器的优势，并发执行让系统运行的更快，更流畅，用户体验更好ios有3种多线程编程的技术：1.NSThread，2.NSOperationQueue，3.gcd 类变量的@protected ,@private,@public,@package，声明各有什么含义？ @private：作用范围只能在自身类 @protected：作用范围在自身类和继承自己的子类 （默认） @public：作用范围最大，可以在任何地方被访问。 @package 只能在框架内访问，框架之外不能访问，也就是说本包内可以使用，跨包就不行 storyboard的各自优劣 局限就是当你和很多人一起开发的时候，因为Storyboards会保存所有的文件在一个文件中，所以分享是非常困难的 重用性不好，你可以重用，但是没有NIBS那样直接 苹果内购实现流程123456781. 程序通过bundle存储的plist文件得到产品标识符的列表。2. 程序向App Store发送请求，得到产品的信息。3. App Store返回产品信息。4. 程序把返回的产品信息显示给用户（App的store界面）5. 用户选择某个产品6. 程序向App Store发送支付请求7. App Store处理支付请求并返回交易完成信息。8. App获取信息并提供内容给用户。 objective-c中runtime是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。 在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码。 12341. 通过runtime的一系列方法获取类的一些信息2. 关联对象现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。这种情况的一般解决办法就是继承。但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。这个时候，runtime的关联属性就发挥它的作用了3. 方法交换 就是将两个方法的实现交换4. 动态添加方法 什么情况下使用weak关键字，相比assign有什么不同？什么情况使用weak关键字？ 在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理 自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用weak，自定义控件属性一般也使用weak weak 关键字的作用弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为 nil。assign则不会 assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象 IBOutlet连出来的视图属性为什么可以被设置成weak? 因为视图已经对它有一个强引用了 使用block时什么情况会发生引用循环，如何解决？ 只要是一个对象对该block进行了强引用,在block内部有直接使用到该对象 weak属性需要在dealloc中置nil么？ 不需要,在ARC环境无论是强指针还是弱指针都无需在deallco设置为nil,ARC会自动帮我们处理 Objective-C如何对内存管理的,说说你的看法和解决方法? Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池 Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么? Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。 堆和栈的区别 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。 通知, 代理, block,观察者的区别 通知：在iOS中由通知中心进行消息接收和消息广播，是一种一对多的消息传递方式。代理：是一种通用的设计模式，iOS中对代理支持的很好，由代理对象、委托者、协议三部分组成。block：iOS4.0中引入的一种回调方法，可以将回调处理代码直接写在block代码块中，看起来逻辑清晰代码整齐。KVC的本质就是 (键值编码) (通过键值对的方式给对象的属性复制setValue””: forKey””), 在对象创建完成之后,动态(牵扯到运行时)的给对象的属性赋值 KVO 的本质就是(键值监听) 提供一种机制,当指定的对象的属性被修改后,则对象就会接受到通知。 处理内存优化有哪些 不要阻塞主线程，永远不要使主线程承担过多 使用异步线程，一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应 如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片 更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。 使用单例，打开之创建一次， 避免反复处理数据，许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的 选择正确的数据存储选项 小数据使用NSUerDefaults 大数据使用类似SQLite的本地SQL数据库 frame和bounds有什么不同？ frame指的是：该view在父view坐标系统中的位置和大小。bounds指的是：该view在本身坐标系统中 的位置和大小。 类别的作用？继承和类别在实现中有何区别？ Category可以向类中添加新的方法，或者重写已有方法。类别主要有3个作用：将类的实现分散到多个不同文件或多个不同框架中。降低耦合性 category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。 继承可以增加，修改或者删除方法，并且可以增加属性。 类别和类扩展的区别 category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。 图片圆角设置的几张方式 layer 使用了贝塞尔曲线”切割”个这个图片 通过绘图的方式 drawRect方法依赖Core Graphics框架来进行自定义的绘制缺点：它处理touch事件时每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例，那就会很糟糕了 viewcontroller生命周期 当你alloc并init了一个ViewController时，这个ViewController应该是还没有创建view的。ViewController的view是使用了lazyInit方式创建，就是说你调用的view属性的getter：［self view］。在getter里会先判断view是否创建，如果没有创建，那么会调用loadView来创建view。loadView完成时会继续调用viewDidLoad。loadView和viewDidLoad的一个区别就是：loadView时还没有view。而viewDidLoad时view以及创建好了。当view被添加其他view中之前时，会调用viewWillAppear，而之后会调用viewDidAppear。当view从其他view中移出之前时，会调用viewWillDisAppear，而之后会调用viewDidDisappear。当view不在使用，而且是disappeared，受到内存警告时，那么viewController会将viw释放并将其指向nil。 Push Notification 是如何工作的推送通知分为两种,一个是本地推送,一个是远程推送 本地推送:不需要联网也可以推送,是开发人员在APP内设定特定的时间来提醒用户干什么 远程推送:需要联网,用户的设备会于苹果APNS服务器形成一个长连接,用户设备会发送uuid和Bundle idenidentifier给苹果服务器,苹果服务器会加密生成一个deviceToken给用户设备,然后设备会将deviceToken发送给APP的服务器,服务器会将deviceToken存进他们的数据库,这时候如果有人发送消息给我,服务器端就会去查询我的deviceToken,然后将deviceToken和要发送的信息发送给苹果服务器,苹果服务器通过deviceToken找到我的设备并将消息推送到我的设备上,这里还有个情况是如果APP在线,那么APP服务器会于APP产生一个长连接,这时候APPF服务器会直接通过deviceToken将消息推送到设备.第一阶段：.net应用程序把要发送的消息、目的iPhone的标识打包，发给APNS。 第二阶段：APNS在自身的已注册Push服务的iPhone列表中，查找有相应标识的iPhone，并把消息发到iPhone。第三阶段：iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。 dispatch_barrier_async的作用是什么？ barrier:是障碍物的意思,在多个并行任务中间,他就像是一个隔离带,把前后的并行任务分开.dispatch_barrier_async 作用是在并行队列中，等待前面操作并行任务完成再执行dispatch_barrier_async中的任务,如果后面还有并行任务,会开始执行后续的并行任务","tags":[{"name":"iOS","slug":"iOS","permalink":"http://gezhenrong.cn/tags/iOS/"},{"name":"总结","slug":"总结","permalink":"http://gezhenrong.cn/tags/总结/"}]},{"title":"将项目提交到git流程","date":"2016-09-14T09:26:48.000Z","path":"2016/09/14/hello-world/","text":"将项目提交到git流程 git初级应用! github上创建立一个项目用户登录后系统，在github首页，点击页面右下角“New Repository”填写项目信息： project name: hibernate-demo description : my first project 点击“Create Repository”;现在完成了一个项目在github上的创建 创建密钥cd ~/.ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用git如果不是第一次使用，请执行下面的操作,清理原有ssh密钥 $ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* 生成新的密钥 Ssh-keygen –t rsa –C “defnngj@gmai.com”在git中运行下面命令 ssh –T git@github.com 提交到github$ git status //查看当前项目下所有文的状态，如果第一次，你会发现都红颜色的，因为它还没有交给git/github管理。 $ git add . //（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。 Ps:git的强大之处就是有一个本地仓库的概念，在没有网络的情况下可以先将更新的内容提交到本地仓库。 $ git commit –m”new natter ” //对你更新或修改了哪些内容做一个描述。 $ git remote add origin git@github.com:defnngj/hibernate-demo.git 如果你是第一次提交项目，这一句非常重要，这是你本地的当前的项目与远程的哪个仓库建立连接。 Ps: origin可以改为别人的名字，但是在你下一次push（提交）时，也要用你修改之后的名字。 $ git remote -v //查看你当前项目远程连接的是哪个仓库地址 $ git push -u origin master //将本地的项目提交到远程仓库中。 删除了一些文件提交$ git status //可以看到我们删除的哪些文件 $ git add . //删除之后的文件提交git管理。 $ git rm src/com/hzh/hibernate/dao/aaa.java //移除我们删除的那个文件，不然git不允许我们往远程仓库提交。 Ps: 如果你想删除的是某个目录（java包），这里想移除整个目录的内容。 $ git rm src/com/hzh/hibernate/bbb/ -r // -r 会把bbb/目录下的所有内容一次性移动。","tags":[]}]